---
typora-root-url: myimg
---

### 一、博客项目地址  <https://www.cnblogs.com/tqtl911/p/9519225.html>

##### 47、点赞事件的绑定

###### 001、urls.py

```python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),
    path("test/", views.test),

    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$', views.home_site),
    re_path(r'^(?P<username>\w+)/(?P<condition>tag|category|archive>)/(?P<param>.*)/$', views.home_site),

    # 文章详情页面的实现
    re_path(r'^(?P<username>\w+)/articles/(?P<article_id>\d+)$',views.article_detail),

    # 点赞视图url
    path(r'digg/',views.digg),
]

```

###### 003、views.py

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    user = UserInfo.objects.filter(username=username).first()
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()
    # print("article_obj>>>",article_obj,article_obj.pk)
    # print("article_obj>>>",article_obj.desc)

    # 查找当前文章的所有评论，comment和article是多对一的关系
    comment_list=Comment.objects.filter(user=user,article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()
    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____",request)
    print(request.POST)
    print("当前登陆人〉〉〉",request.user)
    article_id=request.POST.get("article_id")
    is_up=json.loads(request.POST.get("is_up"))
    print("is_up>>>",is_up)
    # 点赞的是当前登录人
    user_id=request.user.pk
    print("user_id",user_id)
    ard=ArticleUpDown.objects.create(user_id=user_id,article_id=article_id,is_up=is_up)

    return HttpResponse("ok")
```

###### 003、article.html

```html
{% extends "base.html" %}
{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
    {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>

    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            var is_up = $(this).hasClass("diggit");
            alert(is_up);

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {
                    console.log(data)
                }
            })
        });
    </script>


{% endblock %}
```

显示内容：

![1591498424906](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591498424906.png)

###### 004、点赞视图函数遇到的关于当前登录人问题

在用 <http://127.0.0.1:8000/xu/articles/3> 登陆的时候，显示当前登录人是admin，但是我url里面明显不是admin，应该是xu。怎么提取当前登录人的名字？？

##### 48、点赞数量和数据库同步，使用update

###### 001、views.py中的点赞视图函数

```python
def digg(request):
    print("digg____",request)
    print(request.POST)
    print("当前登陆人〉〉〉",request.user)
    article_id=request.POST.get("article_id")
    is_up=json.loads(request.POST.get("is_up"))
    print("is_up>>>",is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id=request.user.pk
    print("user_id",user_id)
    # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
    ard=ArticleUpDown.objects.create(user_id=user_id,article_id=article_id,is_up=is_up)
    # 使用update增加数据库数据，向Article 的up_count新增一条数据
    if is_up:
        Article.objects.filter(pk=article_id).update(up_count=F("up_count")+1)

    return HttpResponse("ok")
```

###### ps、django中JsonResponse，render(),redirect,HttpResponse各自的作用以及他们的区别

```python
from django.shortcuts import HttpResponse, render, redirect
from django.http import JsonResponse

render()：render方法可接收三个参数，一是request参数，二是待渲染的html模板文件,三是保存具体数据的字典参数。 (只会返回页面内容，但是未发送第二次请求)。（一般需要从服务器返回值给前端模板使用这种方式）

redirect():接受一个URL参数，表示让浏览器跳转去指定URL.redirect 是重定向函数 调用函数后直接跳转到url地址 (发挥了第二次请求，url更新) ，（如果是使用 form表单提交，可以使用这种方式实现页面跳转）

HttpResponse():，在视图的时候，content数据是一个用引号引起来的字符串，所以返回给前端的是一个字符串，                 如果需要将结果以json的形式返回给前端，可以用json.dumps(result)， 这样前端就接受的                 为json格式的

JsonResponse：在视图返回时。data参数是一个字典，不用加引号，返回给前端的是一个json对象（json的字典形式）
```



###### 002、提示点赞只能允许一次的逻辑

views.py

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    user = UserInfo.objects.filter(username=username).first()
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()
    # print("article_obj>>>",article_obj,article_obj.pk)
    # print("article_obj>>>",article_obj.desc)

    # 查找当前文章的所有评论，comment和article是多对一的关系
    comment_list = Comment.objects.filter(user=user, article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()
    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____", request)
    print(request.POST)
    print("当前登陆人〉〉〉", request.user)
    article_id = request.POST.get("article_id")
    is_up = json.loads(request.POST.get("is_up"))
    print("is_up>>>", is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id = request.user.pk
    print("user_id", user_id)
    # 查找当前登录用户 在当前文章和点赞表里的记录是存在
    obj = ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id).first()
    print("当前点击的obj>>>", obj)  # 第一次点击的时候为None
    print("当前点击的obj2222>>>", not obj)
    response = {"state": True} # 判断是否重复点击
    # if not obj:  # 如果不存在，则创建
    if obj is None:  # 如果不存在，则创建
        # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
        ArticleUpDown.objects.create(user_id=user_id, article_id=article_id, is_up=is_up)
        # 查找当前文章这个对象
        queryset = Article.objects.filter(pk=article_id)
        if is_up:  # 如果前端点击的是 赞（True）
            # 则给这个文章的点赞字段总数 加一
            queryset.update(up_count=F("up_count") + 1)
        else:  # 如果前端点击的是 踩（False）
            # 则给当前文章的“踩” 字段总数加一
            queryset.update(down_count=F("down_count") + 1)
    else:  # 如果当前登录人已经点击了赞 或则 踩
        response["state"] = False
        response["handled"] = obj.is_up # 判断是哪一个标签被点击
    print("response-----------", response)
    return JsonResponse(response)


def test(request):
    article_list = Article.objects.all()
    print("article_list>>>", article_list)
    for ret in article_list:
        print(ret.pk)

    return HttpResponse("test page")

```

article_detail.html

ps:当前端的一些参数显示undefine的时候，这个时候要多检查下是否是，前后端的参数命名不一致导致的，我这里就犯了一个错误，后端的handed 写成了handle，导致前端的handle 一直是undefine，造成不管点击哪一个都是   走  $("#digg_tips").html("您已经反对过了！");  这条路径。。。

```html
{% extends "base.html" %}
{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>

    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");
            alert(is_up);

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {
                    console.log("data>>>", data, typeof (data)); //{"state":false,"handled":False}
                    console.log("data.state>>>", data.state);
                    console.log("data.handle>>>", data.handled);
                    if (data.state) {


                    } else {
                        alert("第二次点击");
                        alert(data.handled);


                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")
                        }, 1000)
                    }
                }
            })
        });
    </script>
{% endblock %}


```

###### 003、基于ajax的文章点赞，点踩  事实刷新

article_detail.html

```html
{% extends "base.html" %}
{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>

    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {
                    console.log("data>>>", data, typeof (data)); //{"state":false,"handled":False}
                    console.log("data.state>>>", data.state);
                    console.log("data.handle>>>", data.handled);
                    if (data.state) {
                        if (is_up) {
                            var val = parseInt($("#digg_count").text());
                            $("#digg_count").text(val + 1);
                        } else {
                            var val = parseInt($("#bury_count").text());
                            $("#bury_count").text(val + 1);
                        }
                    } else {
                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")

                        }, 1000)


                    }
                }
            })
        });
    </script>
{% endblock %}
```

##### 49、博客系统文章的评论功能的实现

基本思路：

![1591597817075](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591597817075.png)

###### 001、评论功能 的url

urls.py

```python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),
    path("test/", views.test),

    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$', views.home_site),
    re_path(r'^(?P<username>\w+)/(?P<condition>tag|category|archive>)/(?P<param>.*)/$', views.home_site),

    # 文章详情页面的实现
    re_path(r'^(?P<username>\w+)/articles/(?P<article_id>\d+)$',views.article_detail),

    # 点赞视图url
    path(r'digg/',views.digg),
    # 评论url
    path(r'comment/',views.comment),
]

```

###### 002、评论功能的views.py

views.py

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    # print("====",username)
    user = UserInfo.objects.filter(username=username).first()
    # print("文章详情页面的user对象》〉〉",user)
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()
    # print("article_obj>>>",article_obj,article_obj.pk)
    # print("article_obj>>>",article_obj.desc)

    # 查找当前文章的所有评论，comment和article是多对一的关系
    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()
    comment_list=Comment.objects.filter(article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()

    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____", request)
    print(request.POST)
    print("当前登陆人〉〉〉", request.user)
    article_id = request.POST.get("article_id")
    is_up = json.loads(request.POST.get("is_up"))
    print("is_up>>>", is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id = request.user.pk
    print("user_id", user_id)
    # 查找当前登录用户 在当前文章和点赞表里的记录是存在
    obj = ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id).first()
    print("当前点击的obj>>>", obj)  # 第一次点击的时候为None
    print("当前点击的obj2222>>>", not obj)
    response = {"state": True}  # 判断是否重复点击
    # if not obj:  # 如果不存在，则创建
    if obj is None:  # 如果不存在，则创建
        # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
        ArticleUpDown.objects.create(user_id=user_id, article_id=article_id, is_up=is_up)
        # 查找当前文章这个对象
        queryset = Article.objects.filter(pk=article_id)
        if is_up:  # 如果前端点击的是 赞（True）
            # 则给这个文章的点赞字段总数 加一
            queryset.update(up_count=F("up_count") + 1)
        else:  # 如果前端点击的是 踩（False）
            # 则给当前文章的“踩” 字段总数加一
            queryset.update(down_count=F("down_count") + 1)
    else:  # 如果当前登录人已经点击了赞 或则 踩
        response["state"] = False
        response["handled"] = obj.is_up  # 判断是哪一个标签被点击
    print("response-----------", response)
    return JsonResponse(response)

# 文章评论视图函数
def comment(request):
    print(request.POST)
    article_id = request.POST.get("article_id")
    pid = request.POST.get("pid")
    content = request.POST.get("content")
    user_id = request.POST.get("user_id")
    print("评论的user_id",user_id)
    # 评论和文章是多对一的关系，关键字段在Content评论端
    # 这个时候article_id 指的Comment这个表内部的article_id
    comment_obj = Comment.objects.create(user_id=user_id, article_id=article_id, content=content,parent_comment_id=pid)

    return HttpResponse("ok")

```

###### 003、评论功能的html代码

article_detail.html

```html
{% extends "base.html" %}
{% block content %}

    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>
    <h2 style="color: red">--文章评论区--</h2>
    <div class="commonts">
        <div class="comments">
            <p>评论列表</p>
            <ul class="list-group comment_list">
                {% for comment in comment_list %}
                    <li class="list-group-item">
                        <div>
                            <a href="">#{{ forloop.counter }}楼</a>&nbsp;&nbsp;
                            <span>{{ comment.create_time|date:"Y-m-d H:i" }}</span>
                            <a href=""><span>{{ comment.user.username }}</span></a>
                            <a href="" class="pull-right">回复</a>
                        </div>
                        <div class="comment_con">
                            <p>{{ comment.content }}</p>
                        </div>
                    </li>
                {% endfor %}
            </ul>
        </div>


        <p>发表评论</p>
        <p>
            <!-- 带有一个禁用输入字段的 HTML 表单： -->
            昵称:<input typeof="text" id="tbCommentAuthor" class="author" disabled="disabled" size="50"
                      value="{{ user }}">

        </p>
        <p>评论内容</p>
        <textarea name="" id="comment_content" cols="60" rows="10"></textarea>
        <p>
            <button class="btn btn-default common_btn">提交评论</button>
        </p>
    </div>


    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {

                    if (data.state) {
                        if (is_up) {
                            /* parseInt() 函数可解析一个字符串，并返回一个整数。  */
                            var val = parseInt($("#digg_count").text());
                            $("#digg_count").text(val + 1);
                        } else {
                            var val = parseInt($("#bury_count").text());
                            $("#bury_count").text(val + 1);
                        }
                    } else {
                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")

                        }, 1000)


                    }
                }
            })
        });

        //评论请求
        $(".common_btn").click(function () {
            var pid = "";
            var content = $("#comment_content").val();
            $.ajax({

                url: "/comment/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "content": content,
                    pid: pid,
                    "article_id": "{{ article_obj.pk }}",
                    "user_id": "{{ user.pk }}",
                },
                success: function (data) {
                    console.log(data);
                    //清空评论
                    $("#comment_content").val("")
                }

            })

        })
    </script>


{% endblock %}


```

###### 004、优化评论功能，前端采用ajax进行评论功能的实现，同时实时显示评论

views.py

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    # print("====",username)
    user = UserInfo.objects.filter(username=username).first()
    print("文章详情页面的user对象》〉〉", user)
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()

    # 查找当前文章的所有评论，comment和article是多对一的关系
    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()
    comment_list = Comment.objects.filter(article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()

    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____", request)
    print(request.POST)
    print("当前登陆人〉〉〉", request.user)
    article_id = request.POST.get("article_id")
    is_up = json.loads(request.POST.get("is_up"))
    print("is_up>>>", is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id = request.user.pk
    print("user_id", user_id)
    # 查找当前登录用户 在当前文章和点赞表里的记录是存在
    obj = ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id).first()
    print("当前点击的obj>>>", obj)  # 第一次点击的时候为None
    print("当前点击的obj2222>>>", not obj)
    response = {"state": True}  # 判断是否重复点击
    # if not obj:  # 如果不存在，则创建
    if obj is None:  # 如果不存在，则创建
        # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
        ArticleUpDown.objects.create(user_id=user_id, article_id=article_id, is_up=is_up)
        # 查找当前文章这个对象
        queryset = Article.objects.filter(pk=article_id)
        if is_up:  # 如果前端点击的是 赞（True）
            # 则给这个文章的点赞字段总数 加一
            queryset.update(up_count=F("up_count") + 1)
        else:  # 如果前端点击的是 踩（False）
            # 则给当前文章的“踩” 字段总数加一
            queryset.update(down_count=F("down_count") + 1)
    else:  # 如果当前登录人已经点击了赞 或则 踩
        response["state"] = False
        response["handled"] = obj.is_up  # 判断是哪一个标签被点击
    print("response-----------", response)
    return JsonResponse(response)


def comment(request):
    print(request.POST)
    article_id = request.POST.get("article_id")
    pid = request.POST.get("pid")
    content = request.POST.get("content")
    user_id = request.POST.get("user_id")
    print("评论的user_id", user_id)
    print("评论的username>>>", request.POST.get("user"))

    # 评论和文章是多对一的关系，关键字段在Content评论端
    # 这个时候article_id 指的Comment这个表内部的article_id
    comment_obj = Comment.objects.create(user_id=user_id, article_id=article_id, content=content,
                                         parent_comment_id=pid)

    response = {}
    response["create_time"]=comment_obj.create_time.strftime("%Y-%m-%d %X")
    response["username"]=request.POST.get("user")
    response["content"]=content
    return JsonResponse(response)

```

article_detail.html

一个功能未实现就是ajax提交评论后只显示了时间，内容，提交人，在最前面显示第多少  “楼“ ，无回复按钮

![1591607631001](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591607631001.png)

```html
{% extends "base.html" %}
{% block content %}

    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>
    <h2 style="color: red">--文章评论区--</h2>
    <div class="commonts">
        <div class="comments">
            <p>评论列表</p>
            <ul class="list-group comment_list">
                {% for comment in comment_list %}
                    <li class="list-group-item">
                        <div>
                            <a href="">#{{ forloop.counter }}楼</a>&nbsp;&nbsp;
                            <span>{{ comment.create_time|date:"Y-m-d H:i" }}</span>
                            <a href=""><span>{{ comment.user.username }}</span></a>
                            <a href="" class="pull-right">回复</a>
                        </div>
                        <div class="comment_con">
                            <p>{{ comment.content }}</p>
                        </div>
                    </li>
                {% endfor %}
            </ul>
        </div>


        <p>发表评论</p>
        <p>
            <!-- 带有一个禁用输入字段的 HTML 表单： -->
            昵称:<input typeof="text" id="tbCommentAuthor" class="author" disabled="disabled" size="50"
                      value="{{ username }}">

        </p>
        <p>评论内容</p>
        <textarea name="" id="comment_content" cols="60" rows="10"></textarea>
        <p>
            <button class="btn btn-default common_btn">提交评论</button>
        </p>
    </div>


    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {

                    if (data.state) {
                        if (is_up) {
                            /* parseInt() 函数可解析一个字符串，并返回一个整数。  */
                            var val = parseInt($("#digg_count").text());
                            $("#digg_count").text(val + 1);
                        } else {
                            var val = parseInt($("#bury_count").text());
                            $("#bury_count").text(val + 1);
                        }
                    } else {
                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")

                        }, 1000)


                    }
                }
            })
        });

        //评论请求
        $(".common_btn").click(function () {
            var pid = "";
            var content = $("#comment_content").val();
            $.ajax({

                url: "/comment/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "content": content,
                     pid: pid,
                    "article_id": "{{ article_obj.pk }}",
                    "user_id": "{{ user.pk }}",
                    "user": "{{ username }}",
                },
                success: function (data) {
                    console.log("================",data);
                    var create_time=data.create_time;
                    var username=data.username;
                    var content=data.content;
                    var s = `
                    <li class="list-group-item">
                    <div>
                        <span>${create_time}</span> &nbsp;&nbsp;
                        <a href=""><span>${username}</span></a>
                    </div>
                    <div class="comment_con">
                        <p>${content}</p>
                    </div>
                </li>`;
                    $("ul.comment_list").append(s);

                    //清空评论
                    $("#comment_content").val("");
                }

            })

        })
    </script>


{% endblock %}


```

##### 50、博客之回复功能的实现

###### 001、点击“回复”按钮，光标自动跳转至回复栏；回复的对象@形式出现；

```javascript
        // 回复评论按钮事件,focus()方法 添加函数到 focus 事件。
        // 当 comment_content 字段获得焦点时发生 focus 事件：
    $(".reply_btn").click(function () {
        $("#comment_content").focus();
        var val="@"+$(this).attr("username")+"\n";
        $("#comment_content").val(val);
    });
```

###### 002、子评论提交之pid号的判断处理,清空评论框的pid值；

article_detail.html

```html
{% extends "base.html" %}
{% block content %}

    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>
    <h2 style="color: red">--文章评论区--</h2>
    <div class="commonts">
        <div class="comments">
            <p>评论列表</p>
            <ul class="list-group comment_list">
                {% for comment in comment_list %}
                    <li class="list-group-item">
                        <div>
                            <a href="">#{{ forloop.counter }}楼</a>&nbsp;&nbsp;
                            <span>{{ comment.create_time|date:"Y-m-d H:i" }}</span>
                            <a href=""><span>{{ comment.user.username }}</span></a>
                            <a class="pull-right reply_btn" username="{{ comment.user.username }}">回复</a>
                        </div>
                        <div class="comment_con">
                            <p>{{ comment.content }}</p>
                        </div>
                    </li>
                {% endfor %}
            </ul>
        </div>


        <p>发表评论</p>
        <p>
            <!-- 带有一个禁用输入字段的 HTML 表单： -->
            昵称:<input typeof="text" id="tbCommentAuthor" class="author" disabled="disabled" size="50"
                      value="{{ username }}">

        </p>
        <p>评论内容</p>
        <textarea name="" id="comment_content" cols="60" rows="10"></textarea>
        <p>
            <button class="btn btn-default common_btn">提交评论</button>
        </p>
    </div>


    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {

                    if (data.state) {
                        if (is_up) {
                            /* parseInt() 函数可解析一个字符串，并返回一个整数。  */
                            var val = parseInt($("#digg_count").text());
                            $("#digg_count").text(val + 1);
                        } else {
                            var val = parseInt($("#bury_count").text());
                            $("#bury_count").text(val + 1);
                        }
                    } else {
                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")

                        }, 1000)


                    }
                }
            })
        });

        //评论请求
        var pid="";
        $(".common_btn").click(function () {
            var content = $("#comment_content").val();
            if(pid){
                var index=content.indexOf("\n");
                content=content.slice(index+1);
            }
            $.ajax({
                url: "/comment/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "content": content,
                    pid: pid,
                    "article_id": "{{ article_obj.pk }}",
                    "user_id": "{{ user.pk }}",
                    "user": "{{ username }}",
                },
                success: function (data) {
                    {#console.log("================", data);#}
                    var create_time = data.create_time;
                    var username = data.username;
                    var content = data.content;
                    var s = `
                    <li class="list-group-item">
                    <div>
                        <span>${create_time}</span> &nbsp;&nbsp;
                        <a href=""><span>${username}</span></a>
                    </div>
                    <div class="comment_con">
                        <p>${content}</p>
                    </div>
                </li>`;
                    $("ul.comment_list").append(s);

                    //清空评论框
                    pid = "";
                    $("#comment_content").val("");
                }

            })

        });
        // 回复评论按钮事件
        // focus()方法 添加函数到 focus 事件。
        // 当 comment_content 字段获得焦点时发生 focus 事件：
        $(".reply_btn").click(function () {
            $("#comment_content").focus();
            var val = "@" + $(this).attr("username") + "\n";
            $("#comment_content").val(val);
            pid = $(this).attr("comment_pk");
        });
    </script>
{% endblock %}


```

###### 003、构建子评论，创建评论树

1、子评论的urls.py

```python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),
    path("test/", views.test),

    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$', views.home_site),
    re_path(r'^(?P<username>\w+)/(?P<condition>tag|category|archive>)/(?P<param>.*)/$', views.home_site),

    # 文章详情页面的实现
    re_path(r'^(?P<username>\w+)/articles/(?P<article_id>\d+)$',views.article_detail),

    # 点赞视图url
    path(r'digg/',views.digg),
    # 评论url
    path(r'comment/',views.comment),
    # 评论树url
    path("get_comment_tree/",views.get_coment_tree)
]

```

2、子评论的视图函数

views.py

````python
1、Django中事物的引入，with transaction.atomic()方法的使用；
````

```python
from django.db import transaction  # 事物操作
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    # print("====",username)
    user = UserInfo.objects.filter(username=username).first()
    print("文章详情页面的user对象》〉〉", user)
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()

    # 查找当前文章的所有评论，comment和article是多对一的关系
    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()
    comment_list = Comment.objects.filter(article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()

    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____", request)
    print(request.POST)
    print("当前登陆人〉〉〉", request.user)
    article_id = request.POST.get("article_id")
    is_up = json.loads(request.POST.get("is_up"))
    print("is_up>>>", is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id = request.user.pk
    print("user_id", user_id)
    # 查找当前登录用户 在当前文章和点赞表里的记录是存在
    obj = ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id).first()
    print("当前点击的obj>>>", obj)  # 第一次点击的时候为None
    print("当前点击的obj2222>>>", not obj)
    response = {"state": True}  # 判断是否重复点击
    # if not obj:  # 如果不存在，则创建
    if obj is None:  # 如果不存在，则创建
        # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
        ArticleUpDown.objects.create(user_id=user_id, article_id=article_id, is_up=is_up)
        # 查找当前文章这个对象
        queryset = Article.objects.filter(pk=article_id)
        if is_up:  # 如果前端点击的是 赞（True）
            # 则给这个文章的点赞字段总数 加一
            queryset.update(up_count=F("up_count") + 1)
        else:  # 如果前端点击的是 踩（False）
            # 则给当前文章的“踩” 字段总数加一
            queryset.update(down_count=F("down_count") + 1)
    else:  # 如果当前登录人已经点击了赞 或则 踩
        response["state"] = False
        response["handled"] = obj.is_up  # 判断是哪一个标签被点击
    print("response-----------", response)
    return JsonResponse(response)


def comment(request):
    print(request.POST)
    article_id = request.POST.get("article_id")
    pid = request.POST.get("pid")
    content = request.POST.get("content")
    user_id = request.POST.get("user_id")
    print("评论的user_id", user_id)
    print("评论的username>>>", request.POST.get("user"))

    # 评论和文章是多对一的关系，关键字段在Content评论端
    # 这个时候article_id 指的Comment这个表内部的article_id
    '''
    设置该函数中的所有数据库操作在同一个事物中，
    第一个数据库操作1即使成功保存到数据库中，只要第2个数据操作失败，那么所有该段代码所有涉及的数据库操作都会更改回滚到原来。
    '''
    # 事物操作绑定
    with transaction.atomic():
        comment_obj = Comment.objects.create(user_id=user_id, article_id=article_id, content=content,
                                             parent_comment_id=pid)
        Article.objects.filter(pk=article_id).update(comment_count=F("comment_count") + 1)

    response = {}
    response["create_time"] = comment_obj.create_time.strftime("%Y-%m-%d %X")
    response["username"] = request.POST.get("user")
    response["content"] = content
    return JsonResponse(response)


def get_coment_tree(request):
    '''
    评论树视图函数
    :param request:
    :return:
    '''
    article_id = request.GET.get("article_id")
    ret = list(Comment.objects.filter(article_id=article_id).values("pk", "content", "parent_comment__article_id"))

    return JsonResponse(ret, safe=False)

```

3、子评论的html

article_detail.html

````
评论树不再绑定click事件，直接通过Ajax进行展示；

````



```html
{% extends "base.html" %}
{% block content %}

    <h3 class="text-center">{{ article_obj.title }}</h3>
    <h1>article detail page</h1>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>


    <div id="div_digg">
        {% csrf_token %}
        <div class="diggit action">
            <span class="diggnum" id="digg_count">{{ article_obj.up_count }}</span>
        </div>

        <div class="buryit action">
            <span class="burynum" id="bury_count">{{ article_obj.down_count }}</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color: red"></div>
    </div>
    <hr>
    <div class="commonts list-group">
        <p class="tree_btn" style="color: red;font-size: 25px;">评论树</p>
        <div class="comment_tree">


        </div>
    <hr>
        <script>

                $.ajax({
                    url: "/get_comment_tree/",
                    type: "get",
                    data: {
                        article_id: "{{ article_obj.pk }}"
                    },
                    success: function (data) {
                        console.log(data);
                        $.each(data, function (index, comment_object) {
                            var pk = comment_object.pk;
                            var content = comment_object.content;
                            var parent_comment_id = comment_object.parent_comment_id;
                            if (!parent_comment_id) {
                                {#var s = '<div comment_id=' + pk + '><span>' + content + '</span></div>';#}
                                $(".comment_tree").append(s)

                            }else{
                                $("[comment_id="+parent_comment_id+"]").append(s);
                            }
                        })
                    }
                });
        </script>


        <div class="list-group comment_list">
            <div class="comments">
                <p>评论列表</p>
                <ul class="list-group comment_list">
                    {% for comment in comment_list %}
                        <li class="list-group-item">
                            <div>
                                <a href="">#{{ forloop.counter }}楼</a>&nbsp;&nbsp;
                                <span>{{ comment.create_time|date:"Y-m-d H:i" }}</span>
                                <a href=""><span>{{ comment.user.username }}</span></a>
                                <a class="pull-right reply_btn" username="{{ comment.user.username }}">回复</a>
                            </div>
                            <!-- 判断是否是有父级 pid -->
                            {% if comment.parent_comment_id %}
                                <div class="pid_info well">
                                <p>
                                    {{ comment.parent_comment.user.username }}:{{ comment.parent_comment.content }}
                                </p>

                                </div>
                            {% endif %}

                            <div class="comment_con">
                                <p>{{ comment.content }}</p>
                            </div>
                        </li>
                    {% endfor %}
                </ul>
            </div>


            <p>发表评论</p>
            <p>
                <!-- 带有一个禁用输入字段的 HTML 表单： -->
                昵称:<input typeof="text" id="tbCommentAuthor" class="author" disabled="disabled" size="50"
                          value="{{ username }}">

            </p>
            <p>评论内容</p>
            <textarea name="" id="comment_content" cols="60" rows="10"></textarea>
            <p>
                <button class="btn btn-default common_btn">提交评论</button>
            </p>
        </div>
    </div>

    <!-- 给点赞图片绑定点赞事件 -->
    <script>
        $("#div_digg .action").click(function () {
            // 检查当前 div是否有 diggit 这个属性 ，有则为true，无则为false
            var is_up = $(this).hasClass("diggit");

            //传入ajax事件
            $.ajax({
                url: "/digg/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "is_up": is_up,
                    "article_id": "{{ article_obj.pk }}",
                },
                success: function (data) {

                    if (data.state) {
                        if (is_up) {
                            /* parseInt() 函数可解析一个字符串，并返回一个整数。  */
                            var val = parseInt($("#digg_count").text());
                            $("#digg_count").text(val + 1);
                        } else {
                            var val = parseInt($("#bury_count").text());
                            $("#bury_count").text(val + 1);
                        }
                    } else {
                        if (data.handled) {

                            $("#digg_tips").html("您已经推荐过了！");
                        } else {
                            $("#digg_tips").html("您已经反对过了！");
                        }
                        setTimeout(function () {
                            $("#digg_tips").html("")

                        }, 1000)


                    }
                }
            })
        });

        //评论请求
        var pid = "";
        $(".common_btn").click(function () {
            var content = $("#comment_content").val();
            if (pid) {
                var index = content.indexOf("\n");
                content = content.slice(index + 1);
            }
            $.ajax({
                url: "/comment/",
                type: "post",
                data: {
                    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val(),
                    "content": content,
                    pid: pid,
                    "article_id": "{{ article_obj.pk }}",
                    "user_id": "{{ user.pk }}",
                    "user": "{{ username }}",
                },
                success: function (data) {
                    {#console.log("================", data);#}
                    var create_time = data.create_time;
                    var username = data.username;
                    var content = data.content;
                    var s = `
                    <li class="list-group-item">
                    <div>
                        <span>${create_time}</span> &nbsp;&nbsp;
                        <a href=""><span>${username}</span></a>
                    </div>
                    <div class="comment_con">
                        <p>${content}</p>
                    </div>
                </li>`;
                    $("ul.comment_list").append(s);

                    //清空评论框
                    pid = "";
                    $("#comment_content").val("");
                }

            })

        });
        // 回复评论按钮事件
        // focus()方法 添加函数到 focus 事件。
        // 当 comment_content 字段获得焦点时发生 focus 事件：
        $(".reply_btn").click(function () {
            $("#comment_content").focus();
            var val = "@" + $(this).attr("username") + "\n";
            $("#comment_content").val(val);
            pid = $(this).attr("comment_pk");
        });
    </script>
{% endblock %}


```

##### 51、博客之邮件发送新评论的提醒

settings.py 文件设置

```python
# 配置邮箱信息
'''qq 邮箱的端口信息
接收邮件服务器：pop.qq.com，使用SSL，端口号995
发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587
'''
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_USE_TLS = False   #是否使用TLS安全传输协议(用于在两个通信应用程序之间提供保密性和数据完整性。)
EMAIL_USE_SSL = True    #是否使用SSL加密，qq企业邮箱要求使用
EMAIL_HOST = 'smtp.qq.com'   #发送邮件的邮箱 的 SMTP服务器，这里用了qq邮箱
EMAIL_PORT=465  # qq邮箱的发送邮件的端口号
EMAIL_HOST_USER='2745254260@qq.com' # 发送邮件的账号
EMAIL_HOST_PASSWORD='vboxdwdxhjibdcfa' # 这里从qq邮箱申请的授权码
```

views.py 下的   评论视图函数

```python
# 评论视图函数
def comment(request):

    print(request.POST)
    article_id = request.POST.get("article_id")
    pid = request.POST.get("pid")
    content = request.POST.get("content")
    user_id = request.POST.get("user_id")
    print("评论的user_id", user_id)
    print("评论的username>>>", request.POST.get("user"))

    # 评论和文章是多对一的关系，关键字段在Content评论端
    # 这个时候article_id 指的Comment这个表内部的article_id
    '''
    设置该函数中的所有数据库操作在同一个事物中，
    第一个数据库操作1即使成功保存到数据库中，只要第2个数据操作失败，那么所有该段代码所有涉及的数据库操作都会更改回滚到原来。
    '''
    # 事物操作绑定
    with transaction.atomic():
        comment_obj = Comment.objects.create(user_id=user_id, article_id=article_id, content=content,
                                             parent_comment_id=pid)
        Article.objects.filter(pk=article_id).update(comment_count=F("comment_count") + 1)

    response = {}
    response["create_time"] = comment_obj.create_time.strftime("%Y-%m-%d %X")
    response["username"] = request.POST.get("user")
    response["content"] = content

    # 找当前article_id文章的title标题
    article_title=Article.objects.filter(nid=article_id).first().title
    # print("article_id.title,...",article_title)

    # 发送邮件
    '''
     # send_mail的参数分别是  邮件标题，
     邮件内容，发件箱(settings.py中设置过的那个)，
     收件箱列表(可以发送给多个人),
     失败静默(若发送失败，报错提示我们)
    '''
    send_mail(
        "您的文章%s新增了一条评论"% article_title,
        content,
        settings.EMAIL_HOST_USER,
        ["1187188906@qq.com"]
    )

    return JsonResponse(response)
```

views.py完整代码

```python
from django.db import transaction  # 事物操作
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth
import json
# 发送邮件需要的模块
from django.core.mail import send_mail
from myblog import settings


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    # print("====",username)
    user = UserInfo.objects.filter(username=username).first()
    print("文章详情页面的user对象》〉〉", user)
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()

    # 查找当前文章的所有评论，comment和article是多对一的关系
    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()
    comment_list = Comment.objects.filter(article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, article_id=article_id).all()

    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())


# 点赞视图函数
def digg(request):
    print("digg____", request)
    print(request.POST)
    print("当前登陆人〉〉〉", request.user)
    article_id = request.POST.get("article_id")
    is_up = json.loads(request.POST.get("is_up"))
    print("is_up>>>", is_up)
    # 点赞的是当前登录人  怎么提取当前登录人？？
    user_id = request.user.pk
    print("user_id", user_id)
    # 查找当前登录用户 在当前文章和点赞表里的记录是存在
    obj = ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id).first()
    print("当前点击的obj>>>", obj)  # 第一次点击的时候为None
    print("当前点击的obj2222>>>", not obj)
    response = {"state": True}  # 判断是否重复点击
    # if not obj:  # 如果不存在，则创建
    if obj is None:  # 如果不存在，则创建
        # 前端点击一次，这里的ArticleUpDown 模型就创建一条数据，添加一次点赞数据
        ArticleUpDown.objects.create(user_id=user_id, article_id=article_id, is_up=is_up)
        # 查找当前文章这个对象
        queryset = Article.objects.filter(pk=article_id)
        if is_up:  # 如果前端点击的是 赞（True）
            # 则给这个文章的点赞字段总数 加一
            queryset.update(up_count=F("up_count") + 1)
        else:  # 如果前端点击的是 踩（False）
            # 则给当前文章的“踩” 字段总数加一
            queryset.update(down_count=F("down_count") + 1)
    else:  # 如果当前登录人已经点击了赞 或则 踩
        response["state"] = False
        response["handled"] = obj.is_up  # 判断是哪一个标签被点击
    print("response-----------", response)
    return JsonResponse(response)


# 评论视图函数
def comment(request):

    print(request.POST)
    article_id = request.POST.get("article_id")
    pid = request.POST.get("pid")
    content = request.POST.get("content")
    user_id = request.POST.get("user_id")
    print("评论的user_id", user_id)
    print("评论的username>>>", request.POST.get("user"))

    # 评论和文章是多对一的关系，关键字段在Content评论端
    # 这个时候article_id 指的Comment这个表内部的article_id
    '''
    设置该函数中的所有数据库操作在同一个事物中，
    第一个数据库操作1即使成功保存到数据库中，只要第2个数据操作失败，那么所有该段代码所有涉及的数据库操作都会更改回滚到原来。
    '''
    # 事物操作绑定
    with transaction.atomic():
        comment_obj = Comment.objects.create(user_id=user_id, article_id=article_id, content=content,
                                             parent_comment_id=pid)
        Article.objects.filter(pk=article_id).update(comment_count=F("comment_count") + 1)

    response = {}
    response["create_time"] = comment_obj.create_time.strftime("%Y-%m-%d %X")
    response["username"] = request.POST.get("user")
    response["content"] = content

    # 找当前article_id文章的title标题
    article_title=Article.objects.filter(nid=article_id).first().title
    # print("article_id.title,...",article_title)

    # 发送邮件
    '''
     # send_mail的参数分别是  邮件标题，
     邮件内容，发件箱(settings.py中设置过的那个)，
     收件箱列表(可以发送给多个人),
     失败静默(若发送失败，报错提示我们)
    '''
    send_mail(
        "您的文章%s新增了一条评论"% article_title,
        content,
        settings.EMAIL_HOST_USER,
        ["1187188906@qq.com"]
    )

    return JsonResponse(response)


def get_coment_tree(request):
    '''
    评论树视图函数
    :param request:
    :return:
    '''
    article_id = request.GET.get("article_id")
    ret = list(Comment.objects.filter(article_id=article_id).values("pk", "content", "parent_comment__article_id"))

    return JsonResponse(ret, safe=False)
```

##### 52、数据库模版添加一个字段后报错 You are trying to add a non-nullable field 'name' to contact without a default

```
Django数据库操作中You are trying to add a non-nullable field 'name' to contact without a default错误处理
```

解决方案：

```python
添加字段
content=models.TextField(verbose_name="文章内容")
执行：python manage.py makemirations出现以下错误：


You are trying to add a non-nullable field 'name' to contact without a default; we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit, and let me add a default in models.py
Select an option: 


解决方法：
先给'name'任意初始值：content=models.TextField(verbose_name="文章内容"，default='abc')
然后执行：python manage.py makemirations
再执行：python manage.py migrate

```

##### 53、富文本编辑器的使用

##### 54、自定义分页器的引用

##### 55、render（）的时候，locals()和{}传值造成前端页面乱码

使用造成错误

```python
return render(request, "index.html", {"article_list": article_list},locals())
这样使用会造成前端页面乱码，删除一个即可
正确使用方法：
return render(request, "index.html",locals())
```

##### 56、暂停后续的curd功能（使用startk组件）的实现，复习re

###### 001、正则表达式的基本复习

```python
import re

s = "abc123def"
'''
    \d  匹配所有的数字
    \D  匹配所有的非数字
    ^   表示这整个字符串是否是以什么开始，$ 表示整个输入字符串是否以什么结尾
        re里面 ^  表示非  例如  [^a-zA-Z] 表示匹配 不在这个表达式里的的字符串
    +   表示匹配一次或更多次
    ?   匹配0次或则1次
    *   匹配0个或则多个字符
    []  表示字符组
    
    {n}  重复n次
    {n,} 重复n次或更多次
    {n,m} 重复n次到m次 
    
    量词  ？ 代表前面的一个字符出现0次或则一次（出现或则不出现）
    例如：colou?r
     
    前面的u出现一次  则是匹配  colour
    前面的u不出现     则是匹配   color
    
    
    原字符  \b  匹配一个单词的结尾，看这个单词是否是以什么结尾
    
    例如： hello  plp plo
    
    o\b   则是代表这个单词是否是以0结尾，上诉则是有两个匹配结果  hello plo
    
    再比如  匹配一个单词是末尾是否是以an结尾
    sand  an  angle 
    
    re匹配 ：an\b  则匹配结果只有 an  ，an必须是结尾处，且a之后只能是n
    
    \d 表示匹配数字
    例如：\d*    当我写匹配  “你好” 的时候，会出现三个匹配结果  “你好”前面的空字符串不是数字，则算一次，* 代表出现0次或则多次，那“你” “好”
    各出现一次，则总共出现 了三次    
    
    例如：\d*  匹配    123456789的时候，匹配结果只有2次 因为  你开始是  1  是符合的，* 代表出现0次或则多次，
    则 后面的出现多个数字都是符合结果的，只能算作出现一次，所以总共出现2次结果 
    
    
    \d+ 则表示出现1次或则多次
    例如： 123，只能表示出现一次   “你好，我叫456”  则匹配结果是456  ，结果出现一次
    * + 是限制前面 \d 出现的次数
    
    
    正则匹配日期格式的时候是：\d{4}(\-|\/|.)\d{1,2}\1\d{1,2}
    . 这里可以表示 任意字符串，但是如果给 . 加上\   (\-|\/|\.)意思是不转义，就让他为. 
    \1 表示  (\-|\/|.) 这里的结果  如果是 -则 \1 为- ,如果(\-|\/|.) 表示 . 这种格式，则,\1 表示 .  
    
    
    
'''

'''

re.findall()表示查找所有，返回list

'''
# 从字符串 s 中提取数字部分的内容(匹配一次)：
print(re.findall(r"\d",s)) # ['1', '2', '3']
print(re.findall(r"\d+",s)) # ['123']
# 从字符串 s 中提取字母部分的内容(匹配一次)：
print(re.findall(r"\D",s)) # ['a', 'b', 'c', 'd', 'e', 'f']
print(re.findall(r"\D+",s)) # ['abc', 'def']

print(re.findall(r"\w+",s) ) # # ['abc123def']

# 匹配实例
# 匹配 数字下划线和连接符-，并设置长度为3-15
#  ^[a-z0-9_-]{3,15}$

# 案例：  匹配以数字开头，并以 abc 结尾的字符串。：
#  [] 表示字符组，[abc]，会匹配a或b或c
#  - 可用于匹配字符组内所有内容，例如[a-z]匹配a到z之间所有的字母，[0-9]匹配0到9之间的所有数字
ss = "123a/bc"
ret = r"/^[0-9]+abc$/"  # + 表示贪婪匹配  匹配更多结果
print(re.findall(ret, ss))

# ^[0-9]abc$
print(r"\n")
```

###### 002、python的re表达式

````

````

##### 57、在写homesite的跳转的时候，前端的a标签路由包含中文字符串，是类似于

````
http://127.0.0.1:8000/admin/tag/%E6%97%A5%E6%9C%AC%E5%B0%8F%E8%AF%B4/
````

产生乱码，后台无法识别这个路由，也无法接受参数