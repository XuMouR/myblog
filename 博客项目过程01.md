---
typora-root-url: myimg
---

### 一、博客项目地址  <https://www.cnblogs.com/tqtl911/p/9519225.html>

#### 一、项目过程

##### 01 、将项目默认数据库修改为mysql数据库

```
下载MySQLdb
pip3 install MySQLdb
之后再总项目文件下的__init__.py 文件中声明我们要使用mysql数据库
```

之后操作：

```
然后settings.py配置数据库，数据库要事先创建好
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': "myblog",
        "USER":"root",
        "HOST":"127.0.0.1",
        "PASSWORD":"?xmk1024",
        "PORT":3306,
    }
}


```

##### 02、创建app  blog

```
python3 manage.py startapp blog
```

##### 03、blog/models.py 创建模型

```python
from django.db import models

# Create your models here.
from django.contrib.auth.models import AbstractUser
'''
    共八张表
'''

class UserInfo(AbstractUser):
    '''
    用户信息
    '''
    nid=models.AutoField(primary_key=True)
    telephone=models.CharField(max_length=11,null=True,unique=True)
    avatar=models.FileField(upload_to="avatars/",default="/avatars/default.png")
    # auto_now无论是你添加还是修改对象，时间为你添加或者修改的时间。
    # auto_now_add为添加时的时间，更新对象时不会有变动。
    create_time=models.DateTimeField(verbose_name="创建时间",auto_now_add=True)
    blog=models.OneToOneField(to="Blog",to_field="nid",null=True,on_delete=models.CASCADE)

    def __str__(self): # 当实例对象调用的时候，返回这个改值
        return self.username
class Blog(models.Model):
    '''
    博客信息
    '''
    nid=models.AutoField(primary_key=True)
    title=models.CharField(verbose_name="个人博客标题",max_length=64)
    site_name=models.CharField(verbose_name="站点名称",max_length=64)
    theme=models.CharField(verbose_name="博客主题",max_length=32)

    def __str__(self):
        return self.title

class Category(models.Model):
    '''
    博主个人文章分类
    '''
    nid=models.AutoField(primary_key=True)
    title=models.CharField(verbose_name="分类标题",max_length=32)
    blog=models.ForeignKey(verbose_name="所属博客",to="Blog",to_field='nid',on_delete=models.CASCADE)

    def __str__(self):
        return self.title


class Tag(models.Model):
    nid=models.AutoField(primary_key=True) #  primary_key  设置这个键为主键
    title=models.CharField(verbose_name="标题名称",max_length=32)
    blog=models.ForeignKey(verbose_name="所属博客",to="Blog",to_field="nid",on_delete=models.CASCADE)
    def __str__(self):
        return self.title

class Article(models.Model):
    nid=models.AutoField(primary_key=True)
    title=models.CharField(max_length=50,verbose_name="文章标题")
    desc=models.CharField(max_length=255,verbose_name="文章描述")
    # auto_now_add为添加时的时间，更新对象时不会有变动。
    create_time=models.DateTimeField(verbose_name="文章创建时间",auto_now_add=True)
    comment_count=models.IntegerField(verbose_name="评论数量",default=0)
    up_count=models.IntegerField(verbose_name="点赞数量",default=0)
    down_count=models.IntegerField(verbose_name="下载数量",default=0)

    user=models.ForeignKey(verbose_name="作者",to="UserInfo",to_field="nid",on_delete=models.CASCADE)
    # 文章分类
    category=models.ForeignKey(to="Category",to_field="nid",null=True,on_delete=models.CASCADE)
    # through 用于多对多关系时候，定义中间表，到时会多创建一张表Article2Tag
    # through_fields  用于定义中间表的时候，作为关联两个表的 关联字段
    tags=models.ManyToManyField(to="Tag",through="Article2Tag",through_fields=("article","tag"))

    def __str__(self):
        return self.title

class Article2Tag(models.Model):
    nid=models.AutoField(primary_key=True)
    article=models.ForeignKey(verbose_name="文章",to="Article",to_field="nid",on_delete=models.CASCADE)
    tag=models.ForeignKey(verbose_name="标签",to="Tag",to_field="nid",on_delete=models.CASCADE)

    class Meta:
        '''
        unique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。这会在 Django admin
        层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。
        比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：
        unique_together = (("first_name", "last_name"),)
        '''
        unique_together=[
            ('article',"tag")

        ]


    def __str__(self):
        v=self.article.title+"---"+self.tag.title
        return v


class ArticleUpDown(models.Model):
    '''
    点赞表
    '''
    nid=models.AutoField(primary_key=True)
    user=models.ForeignKey("UserInfo",null=True,on_delete=models.CASCADE)
    article=models.ForeignKey("Article",null=True,on_delete=models.CASCADE)
    is_up=models.BooleanField(default=True)

    class Meta:
        unique_together=[
            ("article","user"),
        ]

class Comment(models.Model):
    '''
    评论表
    '''
    nid=models.AutoField(primary_key=True)
    article=models.ForeignKey(verbose_name="评论文章",to='Article',to_field="nid",on_delete=models.CASCADE)
    user=models.ForeignKey(verbose_name="评论者",to="UserInfo",to_field="nid",on_delete=models.CASCADE)
    content=models.CharField(verbose_name="评论内容",max_length=255)
    create_time=models.DateTimeField(verbose_name="评论创建时间",auto_now_add=True)
    parent_comment=models.ForeignKey("self",verbose_name="父级评论", null=True,on_delete=models.CASCADE)

    def __str__(self):
        return self.content
```

##### 04、在settings.py 中声明 使用自己创建的userinfo 用户认证表

```
# 声明 不使用django自带的useinfo表，使用自己的userinfo用户认证表
AUTH_USER_MODEL='blog.UserInfo'
```

##### 05、进行数据迁移操作

```
python3 manage.py makemigrations
python3 manage.py migrate
```

###### 001 、数据库迁移遇到的问题

```
使用的django版本Django      3.0.6
			mysqlclient   1.4.6
			PyMySQL     0.9.3
django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3.

出现的原因：PyMySQL 版本太低
解决方案：
在项目名下的__init__中加入：pymysql.version_info=(1,3,13,"final",0)

或则
注意3:如果报错如下：

1、
django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None
MySQLclient目前只支持到python3.4，因此如果使用的更高版本的python，需要修改如下：

通过查找路径C:\Programs\Python\Python36-32\Lib\site-packages\Django-2.0-py3.6.egg\django\db\backends\mysql
这个路径里的文件把

2、
if version < (1, 3, 3):
     raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)
```

![1590836270677](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1590836270677.png)



执行上面操作后：再数据库迁移，可以行得通

###### 002、执行数据库迁移后遇到只创建了django内部的表，并没有执行我自己创建的表，并报错：

```
WARNINGS:
?: (mysql.W002) MySQL Strict Mode is not set for database connection 'default'
        HINT: MySQL's Strict Mode fixes many data integrity problems in MySQL, such as data truncation upon insertion, by escalating warnings into errors. It i
s strongly recommended you activate it. See: https://docs.djangoproject.com/en/3.0/ref/databases/#mysql-sql-mode
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  No migrations to apply.

说是未为数据库连接“默认”设置MySQL严格模式 ；

```

######  解决方案：

```
自定义用户认证时写错了，django不认。

正确的写法是：
# 声明 不使用django自带的useinfo表，使用自己的userinfo用户认证表
AUTH_USER_MODEL = 'blog.UserInfo'
```

最后报错：django.db.migrations.exceptions.InconsistentMigrationHistory

```
报错django.db.migrations.exceptions.InconsistentMigrationHistory
解决方案：删库跑路，重新建立数据库
```

##### 06、设置静态文件路径

![1590841669410](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1590841669410.png)

```
#静态文件路径 文件夹
STATICFILES_DIRS=[
    os.path.join(BASE_DIR,'static')

]
```

##### 07、博客登陆页面代码编写login.html

```
使用的外部的登陆组件
```

###### 08、登陆页面使用form表单提交的时候，后台没有收到用户的账号密码数据，只有一个<QueryDict: {'csrfmiddlewaretoken': ['fQpFqWWh1DMexWbRMoWwV0iMzuEIGEMdzUzx1G9jERbAiFvCXYvQCZOd3fUx0nKo']}>

```
错误原因：
input的name 属性规定 input 元素的名称。

name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。

注释：只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。


错误的input写法：
 用户名 <input type="text" id="user">  # 不能些id，应该写name
 密码 <input type="text" id="pwd"> # 不能些id，应该写name
    <input type="submit">
    写id之后，无法将元素值提交给表单
```

##### 09、前端form表单的input标签需要注意的事项

```
<input type="text" name="username" placeholder="用户名1">
name="username "    "username"后面如果有空格，后台将无法获得数据
```

###### 10、网上的登陆模版  背景图片加载不了，一直报错404，但是检查路径，没有问题

```
[31/May/2020 14:46:07] "GET /login/assets/img/backgrounds/3.jpg HTTP/1.1" 404 2147
[31/May/2020 14:46:07] "GET /login/assets/img/backgrounds/2.jpg HTTP/1.1" 404 2147
[31/May/2020 14:46:07] "GET /login/assets/img/backgrounds/1.jpg HTTP/1.1" 404 2147
```

##### 11、创建一个超级用户，并用django的auth模块进行用户登陆验证。

```
控制台  python3 manage.py createsuperuser
```

登陆views.py

```python
def login(request):
    if request.method == "GET":

        return render(request, "login.html")
        # return render(request, "login2.html")

    else:
        response = {"user": None, "msg": None}

        username = request.POST.get("username")

        password = request.POST.get("password")
        user = auth.authenticate(username=username, password=password)
        if user:
            response["user"] = user.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request,"login.html",{"response":response})

        return JsonResponse(response)
```

##### 12、进行注册页面的编写

项目urls.py

````
from django.contrib import admin
from django.urls import path
from blog import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/",views.login),
    path("index/",views.index),
    path("register/",views.register),

]
````

基于forms组件的注册页面的后台逻辑编写

```python
# 基于forms组件进行注册代码的编写
from django import forms
# widgets插件，给Form生成的标签添加class等属性
from django.forms import widgets

class UserForm(forms.Form):
    # 用户注册表
    user=forms.CharField(max_length=32,label="用户名",widget=widgets.TextInput(attrs={"class":"form-control"}))
    pwd=forms.CharField(max_length=32,label="密码",widget=widgets.PasswordInput(attrs={"class":"form-control"}))
    r_pwd=forms.CharField(max_length=32,label="确认密码",widget=widgets.PasswordInput(attrs={"class":"form-control"}))
    email=forms.EmailField(max_length=32,label="注册邮箱",widget=widgets.EmailInput(attrs={"class":"form-control"}))


def register(request):
    '''
    注册
    :param request:
    :return:
    '''
    form=UserForm()
    return render(request,"register.html",{"form":form})


```

基于forms组件进行注register.html册页面的，并依据forms组件进行循环渲染标签。register.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <style>
        h1{
            text-align: center;

        }

    </style>
</head>

<body>
<h1>注册页面</h1>
<div class="container">
    <div class="row">
        <div class="col-md-6 col-lg-offset-3">
            <form>
                {% csrf_token %}
                <!-- form渲染 -->
                {% for field in form %}
                    <div class="form-group">
                        <label for="user">{{ field.label }}</label>
                        {{ field }}
                    </div>
                {% endfor %}
                <div class="form-group">
                    <label for="avatar">头像
                        <img id="avatar_img" width="60px" height="60px" scr="/static/blog/bs/img/default.jpg" alt="">
                    </label>
                    <input type="file">
                </div>
                <input type="button" class="btn btn-default login_btn" value="提交">
            </form>
        </div>
    </div>

</div>
<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

</body>
</html>
```

##### 13、注册页面的默认头像功能

- [ ] ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>用户注册</title>
      <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
      <style>
          h1{
              text-align: center;
  
          }
  
      </style>
  </head>
  
  <body>
  <h1>注册页面</h1>
  <div class="container">
      <div class="row">
          <div class="col-md-6 col-lg-offset-3">
              <form>
                  {% csrf_token %}
                  <!-- form渲染 -->
                  {% for field in form %}
                      <div class="form-group">
                          <label for="user">{{ field.label }}</label>
                          {{ field }}
                      </div>
                  {% endfor %}
                  <div class="form-group">
                      <label for="avatar">头像
                          <img id="avatar_img" width="60px" height="60px" src="/static/blog/bs/img/default.jpg" alt="">
                      </label>
                      <input type="file" id="avatar">
                  </div>
                  <input type="submit" class="btn btn-default login_btn" value="提交">
              </form>
          </div>
      </div>
  
  </div>
  <script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>
  
  </body>
  </html>
  ```

##### 14、使用js进行注册页面 头像预览的效果

```javascript
进入register页面的时候是默认的服务器端的头像，点击头像在用户选择对应的头像后，立马变成所选择的头像进行预览效果
头像预览的js代码：
<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

<!-- 进行头像预览操作 -->
<script>
    $("#avatar").change(function () {
        /* 获取用户选中的文件 */
        var file_obj = $(this)[0].files[0];
        /* 获取文件对象的路径 */
        var reader = new FileReader();
        reader.readAsDataURL(file_obj);
        /* 修改img 这个标签的src的属性，也就是改变src这个对象的路径 */
        reader.onload = function () {
            $("#avatar_img").attr("src", reader.result)
        };

    })


</script>
```

注册页面的完整html代码：register.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <style>
        h1 {
            text-align: center;

        }

    </style>
</head>

<body>
<h1>注册页面</h1>
<div class="container">
    <div class="row">
        <div class="col-md-6 col-lg-offset-3">
            <form>
                {% csrf_token %}
                <!-- form渲染 -->
                {% for field in form %}
                    <div class="form-group">
                        <label for="user">{{ field.label }}</label>
                        {{ field }}
                    </div>
                {% endfor %}
                <div class="form-group">
                    <label for="avatar">头像
                        <img id="avatar_img" width="60px" height="60px" src="/static/blog/bs/img/default.jpg" alt="">
                    </label>
                    <input type="file" id="avatar">
                </div>
                <input type="submit" class="btn btn-default login_btn" value="提交">
            </form>
        </div>
    </div>

</div>

<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

<!-- 进行头像预览操作 -->
<script>
    $("#avatar").change(function () {
        /* 获取用户选中的文件 */
        var file_obj = $(this)[0].files[0];
        /* 获取文件对象的路径 */
        var reader = new FileReader();
        reader.readAsDataURL(file_obj);
        /* 修改img 这个标签的src的属性，也就是改变src这个对象的路径 */
        reader.onload = function () {
            $("#avatar_img").attr("src", reader.result)
        };

    })


</script>

</body>
</html>
```

###### 15、js获取文件对象的方法

```
待续。。
```

##### 16、修改注册form表单提交数据为使用Ajax提交数据。为啥是 $("#id_user") 前面都有一#id属性 -->

```javascript
ajax提交form表单数据部分代码：
<!--  基于ajax提交注册信息 -->
<script>
    $(".reg_btn").click(function () {
        var formdata = new FormData();
        formdata.append("user", $("#id_user").val());  <!-- 这里就不是很理解，为啥是 $("#id_user") 前面都有一id属性 -->
        formdata.append("pwd", $("#id_pwd").val());
        formdata.append("r_pwd", $("#id_r_pwd").val());
        formdata.append("email", $("#id_email").val());
        formdata.append("avatar", $("#avatar")[0].files[0]);
        formdata.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());

        ajax({
            url: "",
            contentType: false,
            processData: false,
            data: formdata,
            success: function (data) {
                console.log(data)

            }

        })

    })
</script>
```

完整代码：

###### 问题： <label for="{{ field.auto_id }}">{{ field.label }}</label>

###### AA疑问点AA、 field.auto_id 是什么意思？

解释：其实就是user_id ,pwd_id,email_id 等等

```
Form.auto_id id 和label 的行为使用Form构造函数的auto_id 参数控制。 这个参数必须为True、False 或者一个字符串。默认情况下，auto_id 设置为'id_%s'；auto_id =True ：有lable和id，此时id的值为Form类中的字段名，有空格的会改为_auto_id =False ：没有lable标签和id属性

参考：https://blog.csdn.net/hua1011161696/article/details/80933324
```



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <style>
        h1 {
            text-align: center;

        }

    </style>
</head>

<body>
<h1>注册页面</h1>
<div class="container">
    <div class="row">
        <div class="col-md-6 col-lg-offset-3">
            <form>
                {% csrf_token %}
                <!-- form渲染 -->
                {% for field in form %}
                    <div class="form-group">
                        <label for="field.auto_id">{{ field.label }}</label>
                        {{ field }}
                    </div>
                {% endfor %}
                <div class="form-group">
                    <label for="avatar">头像
                        <img id="avatar_img" width="60px" height="60px" src="/static/blog/bs/img/default.jpg" alt="">
                    </label>
                    <input type="file" id="avatar">
                </div>
                <input type="submit" class="reg_btn btn-default login_btn" value="提交">
            </form>
        </div>
    </div>

</div>

<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

<!-- 进行头像预览操作 -->
<script>
    $("#avatar").change(function () {
        /* 获取用户选中的文件 */
        var file_obj = $(this)[0].files[0];
        /* 获取文件对象的路径 */
        var reader = new FileReader();
        reader.readAsDataURL(file_obj);
        /* 修改img 这个标签的src的属性，也就是改变src这个对象的路径 */
        reader.onload = function () {
            $("#avatar_img").attr("src", reader.result)
        };

    })
</script>

<!--  基于ajax提交注册信息 -->
<script>
    $(".reg_btn").click(function () {
        var formdata = new FormData();
        formdata.append("user", $("#id_user").val());
        formdata.append("pwd", $("#id_pwd").val());
        formdata.append("r_pwd", $("#id_r_pwd").val());
        formdata.append("email", $("#id_email").val());
        formdata.append("avatar", $("#avatar")[0].files[0]);
        formdata.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());

        ajax({
            url: "",
            contentType: false,
            processData: false,
            data: formdata,
            success: function (data) {
                console.log(data)

            }

        })

    })
</script>

</body>
</html>
```

##### 16、基于ajax在注册页面显示错误提示

部分js代码：

```javascript
<!--  基于ajax提交注册信息 -->
<script>
    $(".reg_btn").click(function () {
        var formdata = new FormData();
        formdata.append("user", $("#id_user").val());
        formdata.append("pwd", $("#id_pwd").val());
        formdata.append("r_pwd", $("#id_r_pwd").val());
        formdata.append("email", $("#id_email").val());
        formdata.append("avatar", $("#avatar")[0].files[0]);
        formdata.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());

        $.ajax({
            url: "",
            contentType: false, /* contentType 告诉服务器从浏览器提交过来的数据格式。*/
            /*
             processData
            类型：Boolean
            默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，
            以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。
            */

            processData: false,
            data: formdata,
            global:false,
            success: function (data) {
                console.log(data);
                console.log(data.user);
                if(data.user){
                    //注册成功！
                }else{
                    console.log(data.msg);
                    $.each(data.msg,function (field,error_list) {
                        console.log(field,error_list);
                        $("#id_"+field).next().html(error_list[0])
                    })
                }

            }

        });

    });


</script>
```



完整注册页面代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <style>
        h1 {
            text-align: center;

        }

    </style>
</head>

<body>
<h1>注册页面</h1>
<div class="container">
    <div class="row">
        <div class="col-md-6 col-lg-offset-3">
            <form>
                {% csrf_token %}
                <!-- form渲染 -->
                {% for field in form %}
                    <div class="form-group">
                        <label for="field.auto_id">{{ field.label }}</label>
                        {{ field }}
                    </div>
                {% endfor %}
                <div class="form-group">
                    <label for="avatar">头像
                        <img id="avatar_img" width="60px" height="60px" src="/static/blog/bs/img/default.jpg" alt="">
                    </label>
                    <input type="file" id="avatar">
                </div>
                <input type="submit" class="reg_btn btn-default login_btn" value="提交">
            </form>
        </div>
    </div>

</div>

<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

<!-- 进行头像预览操作 -->
<script>
    $("#avatar").change(function () {
        /* 获取用户选中的文件 */
        var file_obj = $(this)[0].files[0];
        /* 获取文件对象的路径 */
        var reader = new FileReader();
        reader.readAsDataURL(file_obj);
        /* 修改img 这个标签的src的属性，也就是改变src这个对象的路径 */
        reader.onload = function () {
            $("#avatar_img").attr("src", reader.result)
        };

    })
</script>

<!--  基于ajax提交注册信息 -->
<script>
    $(".reg_btn").click(function () {
        var formdata = new FormData();
        formdata.append("user", $("#id_user").val());
        formdata.append("pwd", $("#id_pwd").val());
        formdata.append("r_pwd", $("#id_r_pwd").val());
        formdata.append("email", $("#id_email").val());
        formdata.append("avatar", $("#avatar")[0].files[0]);
        formdata.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());

        $.ajax({
            url: "",
            contentType: false, /* contentType 告诉服务器从浏览器提交过来的数据格式。*/
            /*
             processData
            类型：Boolean
            默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，
            以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。
            */

            processData: false,
            data: formdata,
            global:false,
            success: function (data) {
                console.log(data);
                console.log(data.user);
                if(data.user){
                    //注册成功！
                }else{
                    console.log(data.msg);
                    $.each(data.msg,function (field,error_list) {
                        console.log(field,error_list);
                        $("#id_"+field).next().html(error_list[0])
                    })
                }

            }

        });

    });


</script>

</body>
</html>
```

###### 16.0、（已经解决）但是在浏览器控制台观察console输出内容时，只要输入内容并进行提交时候，就会发生闪退的情况。捕捉不到具体打印的信息（其实是submit自动提交了一次，再加上我自己提交，），一共是提交了2次form表单

```
错误原因：在form表单提交数据的时候，定义的提交按钮是：
<input type="submit" class="btn btn-default reg_btn" value="提交">,在点击提交按钮后，浏览器url地址会发生变化，错误信息不会被显示在边边框右边。
```

###### 解决方案

```
修改按钮类型：
<input type="button" class="btn btn-default reg_btn" value="提交">
```

###### 16（button和submit不同）拓展：

```
html中submit和button二者都以按钮的形式展现,看起来都是按钮，所不同的是type属性和处发响应的事件上，submit会提交表单，button不会提交表单。
submit和button两者主要区别在于：
1、submit默认为form提交，可以提交表单（form）。submit其实是button的一个特例，也是button的一种，它把提交这个动作自动集成了。
2、button作为普通的按钮则响应用户自定义的事件,如果不指定onclick等事件处理函数，它是不做任何事情，不会自动提交表单数据。当然，button也可以通过JS代码完成表单提交的工作。比如: onclick="document.form1.submit()"。
3、如果表单在点击提交按钮后需要用JS进行处理（包括输入验证）后再提交的话，通常都必须把submit改成button，即取消其自动提交的行为，否则，将会造成提交两次的效果，对于动态网页来说，也就是对数据库操作两次。或者在使用submit时验证时加return true或false。

参考：https://www.cnblogs.com/DarryZz04/p/11105971.html
https://blog.csdn.net/aiming66/article/details/79046432
```

##### 17、forms组件的局部钩子和全局钩子的使用

```
第一点：from django.core.exceptions import NON_FIELD_ERRORS, ValidationError的引入；
第二点：抛出中文异常提示
第三点：cleaned_data的用法
```

局部钩子部分代码：app/view.py

```python
# form组件的钩子需要使用的模块
from blog.models import UserInfo
from django.core.exceptions import NON_FIELD_ERRORS, ValidationError


class UserForm(forms.Form):
    # 用户注册表
    user = forms.CharField(max_length=32, label="用户名",
                           widget=widgets.TextInput(attrs={"class": "form-control"}),
                           error_messages={
                               "required": "用户名不能为空"
                           })
    pwd = forms.CharField(max_length=32, label="密码",
                          widget=widgets.PasswordInput(attrs={"class": "form-control"}),
                          error_messages={
                              "required": "密码不能为空"
                          })
    r_pwd = forms.CharField(max_length=32, label="确认密码",
                            widget=widgets.PasswordInput(attrs={"class": "form-control"}),
                            error_messages={
                                "required": "确认密码不能为空"
                            })
    email = forms.EmailField(max_length=32, label="注册邮箱",required=False,
                             widget=widgets.EmailInput(attrs={"class": "form-control"}))
    # 
    def clean_user(self):
        user = self.cleaned_data.get("user")
        user = UserInfo.objects.filter(username=user).first()
        if not user:
            return user
        else:
            raise ValidationError("用户名已经被注册")

    def clean(self):
        pwd = self.cleaned_data.get("pwd")
        r_pwd = self.cleaned_data.get("r_pwd")

        if pwd == r_pwd:
            return self.cleaned_data
        else:
            raise ValidationError("两次密码不一致")
```

完整代码：app/views.py

````python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse

# Create your views here.
from django.contrib import auth


def login(request):
    if request.method == "GET":

        return render(request, "login.html")
        # return render(request, "login2.html")

    else:
        response = {"user": None, "msg": None}

        username = request.POST.get("username")

        password = request.POST.get("password")
        user = auth.authenticate(username=username, password=password)
        if user:
            response["user"] = user.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        return JsonResponse(response)


def index(request):
    print("index ok")

    return render(request, "index.html")


# 基于forms组件进行注册代码的编写
from django import forms
# widgets插件，给Form生成的标签添加class等属性
from django.forms import widgets

# form组件的钩子需要使用的模块
from blog.models import UserInfo
from django.core.exceptions import NON_FIELD_ERRORS, ValidationError


class UserForm(forms.Form):
    # 用户注册表
    user = forms.CharField(max_length=32, label="用户名",
                           widget=widgets.TextInput(attrs={"class": "form-control"}),
                           error_messages={
                               "required": "用户名不能为空"
                           })
    pwd = forms.CharField(max_length=32, label="密码",
                          widget=widgets.PasswordInput(attrs={"class": "form-control"}),
                          error_messages={
                              "required": "密码不能为空"
                          })
    r_pwd = forms.CharField(max_length=32, label="确认密码",
                            widget=widgets.PasswordInput(attrs={"class": "form-control"}),
                            error_messages={
                                "required": "确认密码不能为空"
                            })
    email = forms.EmailField(max_length=32, label="注册邮箱",required=False,
                             widget=widgets.EmailInput(attrs={"class": "form-control"}))
    #
    def clean_user(self):
        user = self.cleaned_data.get("user")
        user = UserInfo.objects.filter(username=user).first()
        if not user:
            return user
        else:
            raise ValidationError("用户名已经被注册")

    def clean(self):
        pwd = self.cleaned_data.get("pwd")
        r_pwd = self.cleaned_data.get("r_pwd")

        if pwd == r_pwd:
            return self.cleaned_data
        else:
            raise ValidationError("两次密码不一致")


def register(request):
    '''
    注册
    :param request:
    :return:
    '''

    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        # print(request.POST)
        # 在 form.is_valid()校验玩后，打印form.cleaned_data 才不会报错，未检验成功之前会报错
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            # print(response["user"])

        else:
            print(form.errors)
            # print(form.cleaned_data)
            response["msg"] = form.errors
        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面

    return render(request, "register.html", {"form": form})

````

##### 18、将中文异常显示在前端注册代码文件中 register.html,但是会出现  快速刷新页面 的情况(以解决。是提交的按钮问题，将submit改为button即可)

register.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <style>
        h1 {
            text-align: center;
        }

        #avatar {
            display: none;
        }

        .error {
            color: red;

        }

        #avatar_img {
            margin-left: 20px;

        }

    </style>
</head>

<body>
<h1>注册页面</h1>
<div class="container">
    <div class="row">
        <div class="col-md-6 col-lg-offset-3">
            <form id="form">
                {% csrf_token %}
                <!-- form渲染 -->
                {% for field in form %}
                    <div class="form-group">
                        <!--Form.auto_id id 和label 的行为使用Form构造函数的auto_id 参数控制。 这个参数必须为True、False 或者一个字符串。
                            默认情况下，auto_id 设置为'id_%s'；
                            auto_id =True ：有lable和id，此时id的值为Form类中的字段名，有空格的会改为_
                            auto_id =False ：没有lable标签和id属性
                        -->
{#                        <h1 style="color: red">{{ field.auto_id }}</h1>#}
                        <label for="{{ field.auto_id }}">{{ field.label }}</label>
                        {{ field }} <span class="error pull-right"></span>
                    </div>
                {% endfor %}
                <div class="form-group">
                    <label for="avatar">头像
                        <img id="avatar_img" width="60px" height="60px" src="/static/blog/bs/img/default.jpg" alt="">
                    </label>
                    <input type="file" id="avatar" name="avatar">
                </div>
                <input type="button" class="btn btn-default reg_btn" value="提交">
            </form>
        </div>
    </div>

</div>

<script src="/static/blog/bs/js/jquery-1.8.2.min.js"></script>

<!-- 进行头像预览操作 -->
<script>
    $("#avatar").change(function () {
        // 获取用户选中的文件
        var file_obj = $(this)[0].files[0];
        /* 获取文件对象的路径 */
        var reader = new FileReader();
        reader.readAsDataURL(file_obj);
        /* 修改img 这个标签的src的属性，也就是改变src这个对象的路径 */
        reader.onload = function () {
            $("#avatar_img").attr("src", reader.result)
        };

    })
</script>

<!--  基于ajax提交注册信息 -->
<script>
    $(".reg_btn").click(function () {
        alert("点击提交按钮");
        var formdata = new FormData();
        formdata.append("user", $("#id_user").val());
        formdata.append("pwd", $("#id_pwd").val());
        formdata.append("r_pwd", $("#id_r_pwd").val());
        formdata.append("email", $("#id_email").val());
        formdata.append("avatar", $("#avatar")[0].files[0]);
        formdata.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());
        console.log("formdata>>",formdata);

        $.ajax({
            url:"",
            type:"post",
            contentType: false, /* contentType 告诉服务器从浏览器提交过来的数据格式。*/
            /*
             processData
            类型：Boolean
            默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，
            以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。
            */
            data: formdata,
            processData: false,

            {#global: false,#}
            success: function (data) {
                alert("注册陈宫01");
                console.log(data);
                console.log(data.user);
                if (data.user) {
                    //注册成功！
                    alert("注册成功");
                    console.log("data>>>", data);
                } else {
                    //注册失败
                    // 清空错误消息提示
                    $("span.error").html();
                    // has-error是bootstrap中的一个class
                    $(".form-group").removeClass("has-error");
                    // 这里each是遍历这个data.msg 二维数组的每一个元素，而field则是每一个元素的下标，
                    // error_list则表这个一维数组的每一个二维数组
                    $.each(data.msg, function (field, error_list) {
                        alert(error_list);
                        console.log(field, error_list);
                        if (field == "__all__") {
                            $("#id_r_pwd").next().html(error_list[0]).parent().addClass("has-error")
                        }
                        $("#id_"+ field).next().html(error_list[0]);

                        $("#id_"+ field).parent().addClass("has-error");

                    })
                }

            }

        });

    });
</script>

</body>
</html>

```

##### 18、博客系统之FileFiled字段

```
 01.遇到bug：在数据进行 form.is_valid之后，提取干净数据的时候
  user = form.cleaned_data.get("user")  无法拿到注册的用户名，
  其他的都可以拿到数据:  
  pwd = form.cleaned_data.get("pwd")
  email = form.cleaned_data.get("email")
  
 已经解决：是因为在form  局部钩子验证user的时候，将用户输入的user名字和  将输入user名字到数据库查找的结果user_obj（新用户注册，名字在数据库里面没有，所以user_obj 为None）,重名了。
```

###### 19、小知识温习（Django项目的模板路径问题）

```
BASE_DIR是指mysite项目的绝对路径。

'DIRS': [os.path.join(BASE_DIR, 'templates')]  是指到  BASE_DIR/templates文件夹中去取模板

'DIRS': [os.path.join(BASE_DIR, 'app1/templates')] 是指导  BASE_DIR/app1/templates文件夹中去取模板


一般来说，应该设置'DIRS': [os.path.join(BASE_DIR, 'templates')]，公用的templates需要指定。
app1专用的templates，放在app1/templates下，可以不需指定。因为在app1.views中若要指定一个专用模板，只要直接写‘app1_index.html’，Django服务器会在views文件所在的当前层（/app1）中找到templates,从而找到模板'app1_index.html'.


指定公用的templates路径，所有apps都可以调用，方便快捷。
app专用的templates不需要指定，这样当要复用这个app的时候，不需要考虑templates路径问题。
```

###### 20、join的用法

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
str = "-";
seq = ("a", "b", "c"); # 字符串序列
print str.join( seq );
```

###### 21、序列化和反序列化，json的复习

```

```

##### 二、记一次因为命名不规范的惨痛教训

```python
一次使用forms组件进行注册时，前端传入注册信息给后端，在forms组件的局部钩子中进行  用户名认证的时候，将
    def clean_user(self):
        user = self.cleaned_data.get("user")
        print("钩子中的user〉〉〉", user)
        user_obj = UserInfo.objects.filter(username=user).first()
        print("从数据库中匹配的user对象〉〉〉",user_obj)
        if not user_obj:
            return user
        else:
            raise ValidationError("用户名已经被注册")
 其中的user和user_obj的名字写成一样了，造成新用户注册时，user_obj为None  然后return给注册视图函数（def register）的form.is_valid():始终取的user 数据为None  ，难怪其他数据邮箱，密码等可以取到，只有用户名取不到的现象。。。。惨痛的教训。。
```

##### 22、进行注册用户的信息数据写入数据库（此时用到的是models.py中的用户类）

view.py/def register  部分代码：

```python
if avatar_obj:
	# 将新用户注册信息写入数据库
	ser_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, 	avatar=avatar_obj)
else:
	# 使用默认头像
 	user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
    
```

完整代码：

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo


def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        return JsonResponse(response)


def index(request):
    print("index ok")

    return render(request, "index.html")


def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})

```

###### 23、django用户模型创建新用户并写入数据库的create()和create_user()  两种方法的区别

```
例如：
user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)


create()可以将数据写入到数据库，但是当password写入数据库后，在数据库是明文显示的，当用这个明文的密码去登陆的时候是无法登陆成功的

create_user()数据写入数据库，password是经过加密的，再次用注册的密码登陆的时候，是可以直接登陆的
```

###### ？？？？？23、进行客户头像上传的保存路径（media配置）这个有什么用？

settings.py

```
新建media文件夹，图像上传后，会自动建立avatar文件夹
配置：MEDIA_ROOT=os.path.join(BASE_DIR, "static/media")
```

![1591028280690](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591028280690.png)

````
1、settings.py中MEDIAZ_URL的配置；
2、urls.py中MEDIA_ROOT的引用而不是MEDIA_URL；
````

![1591028470307](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591028470307.png)

![1591028672165](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591028672165.png)

##### 24、博客系统之系统首页的导航区域

主要需求及技术点

```
1、Bootstrap之导航条的使用；
2、{{ request.user.username }}的使用；
3、auth.logout(request) # 等同于request.session.flush()；
```

###### 24.1 bootstrap的导航栏在index页面的使用

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客首页！</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/bs/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style>
        #use_icon {
            font-size: 18px;
            margin-right: 10px;
            vertical-align: -3px;
        / / vertical-align 属性设置元素的垂直对齐方式。
        }
    </style>

</head>
<body>
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">导航栏</span>
                <span class="icon-bar">1</span>
                <span class="icon-bar">2</span>
                <span class="icon-bar">3</span>
            </button>
            <a class="navbar-brand" href="#">我的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active"><a href="#">随笔 <span class="sr-only">(current)</span></a></li>
                <li><a href="#">新闻</a></li>
                <li><a href="#">博文</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                {% if request.user.is_authenticated %}
                    <li><a href="#"><span id="user_icon"
                                          class="glyphicon glyphicon-user"></span>{{ request.user.username }}</a></li>

                    <li class="dropdown">

                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                           aria-expanded="false">Dropdown <span class="caret"></span></a>

                        <ul class="dropdown-menu">
                            <li><a href="#">Action</a></li>
                            <li><a href="#">Another action</a></li>
                            <li><a href="#">Something else here</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">Separated link</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">One more separated link</a></li>
                        </ul>
                    </li>
                {% else %}
                    <li><a href="/login/">登陆</a></li>
                    <li><a href="/register/">注册</a></li>
                {% endif %}

            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>
</body>
</html>
```

效果显示：	

![1591063389164](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591063389164.png)

##### 25.基于Django的auth 模块实现账户注销功能

views.py

```python
# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")

```

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客首页！</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/bs/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style>
        #use_icon {
            font-size: 18px;
            margin-right: 10px;
            vertical-align: -3px;
        / / vertical-align 属性设置元素的垂直对齐方式。
        }
    </style>

</head>
<body>
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">导航栏</span>
                <span class="icon-bar">1</span>
                <span class="icon-bar">2</span>
                <span class="icon-bar">3</span>
            </button>
            <a class="navbar-brand" href="#">我的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active"><a href="#">随笔 <span class="sr-only">(current)</span></a></li>
                <li><a href="#">新闻</a></li>
                <li><a href="#">博文</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                {% if response.user %}
{#                {% if request.user.is_authenticated %}#}
                    <li><a href="#"><span id="user_icon"
                                          class="glyphicon glyphicon-user"></span>&nbsp;欢迎你,{{ response.user }}</a></li>

                    <li class="dropdown">

                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                           aria-expanded="false">操作 <span class="caret"></span></a>

                        <ul class="dropdown-menu">
                            <li><a href="#">修改密码</a></li>
                            <li><a href="#">修改头像</a></li>
                            <li><a href="/logout/">注销</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">Separated link</a></li>
                        </ul>
                    </li>
                {% else %}
                    <li><a href="/login/">登陆</a></li>
                    <li><a href="/register/">注册</a></li>
                {% endif %}

            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>
</body>
</html>
```

##### 26、引入bootstrap的栅格，将页面定制

##### 27、基于admin，将应用app的models在admin.py中进行表注册，当然需要事先创建django的超级用户账号

```python
 python3 manage.py createsuperuser  
一步步操作就可以了，创建的超级用户名会在你指定的userinfo 表中用存储
```

admin.py中注册app模型

```python
from django.contrib import admin

# Register your models here.
from .models import  UserInfo,Blog,Category,Tag,Article,Article2Tag,ArticleUpDown,Comment


admin.site.register(UserInfo)
admin.site.register(Blog)
admin.site.register(Category)
admin.site.register(Tag)
admin.site.register(Article)
admin.site.register(Article2Tag)
admin.site.register(ArticleUpDown)
admin.site.register(Comment)
注册完之后进行django管理员登陆  然后 进行数据的录入

```

![1591068260324](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591068260324.png)

##### 28、将录入的文章进行index首页的渲染

views.py

```python
# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})

```

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客首页！</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/bs/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style>
        #use_icon {
            font-size: 18px;
            margin-right: 10px;
            vertical-align: -3px;
        / / vertical-align 属性设置元素的垂直对齐方式。
        }
    </style>

</head>
<body>
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">导航栏</span>
                <span class="icon-bar">1</span>
                <span class="icon-bar">2</span>
                <span class="icon-bar">3</span>
            </button>
            <a class="navbar-brand" href="#">我的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active"><a href="#">随笔 <span class="sr-only">(current)</span></a></li>
                <li><a href="#">新闻</a></li>
                <li><a href="#">博文</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                {% if response.user %}
                    {#                {% if request.user.is_authenticated %}#}
                    <li><a href="#"><span id="user_icon"
                                          class="glyphicon glyphicon-user"></span>&nbsp;欢迎你,{{ response.user }}</a></li>

                    <li class="dropdown">

                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                           aria-expanded="false">操作 <span class="caret"></span></a>

                        <ul class="dropdown-menu">
                            <li><a href="#">修改密码</a></li>
                            <li><a href="#">修改头像</a></li>
                            <li><a href="/logout/">注销</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">Separated link</a></li>
                        </ul>
                    </li>
                {% else %}
                    <li><a href="/login/">登陆</a></li>
                    <li><a href="/register/">注册</a></li>
                {% endif %}

            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>


<!-- bootstrap 栅格的引入 -->

<div class="container-fluid">
    <div class="row">
        <div class="col-md-3">
            <div class="panel panel-warning">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
            <div class="panel panel-info">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
            <div class="panel panel-danger">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="article_list">
                {% for articel in article_list %}
                    <div class="articel-item">
                        <h5><a href="">{{ articel.title }}</a></h5>
                        <div class="article-desc">
                        <span class="media-left">
                            <a href=""><img width="56" height="56" src="media/{{ articel.user.avatar }}" alt=""></a>
                        </span>
                            <span class="media-right">
                            {{ articel.desc }}
                        </span>
                        </div>
                        <hr>
                    </div>
                    <div class="small pub_info">

                        <span><a href="">{{ articel.user.username }}</a></span>&nbsp;&nbsp;&nbsp;
                        <span>发布于&nbsp;&nbsp;{{ articel.create_time|date:"Y-m-d H:i" }}</span>
                        <span class="glyphicon glyphicon-comment"></span>评论({{ articel.comment_count }})
                        <span class="glyphicon glyphicon-thumbs-up"></span>点赞({{ articel.up_count }})
                    </div>
                {% endfor %}
            </div>
        </div>
        <div class="col-md-3">
            <div class="panel panel-default">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
            <div class="panel panel-primary">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">Panel heading without title</div>
                <div class="panel-body">
                    Panel content
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
```

效果图：

![1591078402717](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591078402717.png)

##### 29、博客个人站点的页面的文章查询

01、新增个人站点home_site路由

项目 urls.py

```
	
```

#### 30、暂停博客内容 ，先复习orm操作

01、orm 单表操作

```python
单表：models.py
from django.db import models

# Create your models here.

class Book(models.Model):
    id=models.AutoField(primary_key=True)
    title=models.CharField(max_length=32)
    state=models.BooleanField()
    pub_date=models.DateField()
    price=models.DecimalField(max_digits=8,decimal_places=2)
    publish=models.CharField(max_length=32)

    # __str__方法需要返回一个字符串，当做这个对象的描写
    def __str__(self):
        return self.title

    class Meta:
        db_table="book"
```

02、单表增删改查

```

```

查询  以时间查询对象

```python

import datatime
查询出版时间为2019-6-20的书籍
ret2 = Book.objects.filter(pub_date=datetime.date(2019, 6, 20))

# 查询2019年6月出版的所有书籍
ret3=Book.objects.filter(pub_date__year=2019,pub_date__month=6)

# 查询在2019年6月之后出版的书籍
ret4 = Book.objects.filter(pub_date__gt=datetime.date(2019, 6, 30))

# 查询出版时间在2019年3月31日到2019年9月30号之间出版的书籍
start_time = datetime.datetime(2019, 3, 31) # 2019-03-31 00:00:00
print(start_time)
end_time = datetime.datetime(2019, 9, 30)
ret5 = Book.objects.filter(pub_date__range=(start_time, end_time))
## ret5 <QuerySet [<Book: book01>, <Book: ADC>, <Book: bType>]>
```

###### 31、values查询得到的是一个queryset，里面包含的是一个个字典

```python
queryset = Book.objects.filter(price=200).values("title", "price")
print(queryset, type(queryset))  # <QuerySet [{'title': 'ADC', 'price': Decimal('200.00')}]> <class 'django.db.models.query.QuerySet'>
l = []
for i in queryset:
     print(i,type(i))  #  {'title': 'ADC', 'price': Decimal('200.00')} <class 'dict'>
```

###### 32、 values_list 得到queryset集合，元素是一个元组 tuple

```python
queryset = Book.objects.filter(price=200).values_list("title", "price")
for i in queryset:
	print(i,type(i)) # ('ADC', Decimal('200.00')) <class 'tuple'>
```

33 、ORM查询时，Queryset的可调用方法:

````python
queryset的可调用方法:
          queryset.count() 
          queryset.filter() # 返回的queryset对象
          queryset.order_by()  # 返回的queryset对象
          queryset.reverse()  # 返回的queryset对象
          queryset.values()  # 返回的queryset对象
          queryset.values_list()  # 返回的queryset对象
          queryset.exists  # 返回的布尔值
          queryset.delete()  # 返回的布尔值
````

##### 注意：Book.objects.filter(price=200).values("title", "price")的values的值就是这个里面形成的字典的键：

```
   将queysetappend到l这个列表中
   l=[] # queryset()
   按照这种循环，将每一个对象按照这种字典append到列表中，values里面的就是这个字典的键
   

"""
   for obj in queryset:
      l.append({
         "title":obj.title,
         "price":obj.price,
      })

"""
按照上面这种for循环的思路这样理解这个查找的values里面的值 
      
```

###### 33 value_list和value的区别

```
Book.objects.all().values("title") # 返回queryset对象   [{"title":""},{"title":""}]
Book.objects.all().values_list("title","price") # 返回queryset对象   [("python",122),("linux",233)]
```

###### 34、DateTimeField和DateField和TimeField的区别

```
DateTimeField和DateField和TimeField

存储的内容分别对应着datetime(),date(),time()三个对象。

    对于auto_now和auto_now_add。两者默认值都为False。
    auto_now=Ture，字段保存时会自动保存当前时间，但要注意每次对其实例执行save()的时候都会将当前时间保存，也就是不能再手动给它存非当前时间的值。

    auto_now_add=True，字段在实例第一次保存的时候会保存当前时间，不管你在这里是否对其赋值。但是之后的save()是可以手动赋值的。也就是新实例化一个model，想手动存其他时间，就需要对该实例save()之后赋值然后再save()。
```

###### 35、多对一夸表查询

models.py

```python
from django.db import models


# Create your models here.

# 建立 书籍，出版社，和 作者,作者详情的表及其之间的表关系

class Book(models.Model):
    '''
    书籍表
    '''
    nid = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32, verbose_name="书籍名称")
    publishDate = models.DateField(verbose_name="出版时间")
    price = models.DecimalField(max_digits=5, decimal_places=2, verbose_name="书籍价格")

    # 书籍和publish是 多对一  的关系，字段建立在多的一方 book
    publish = models.ForeignKey(to="Publish", to_field="nid", on_delete=models.CASCADE)
    # book和作者是多对多  ManyToManyField的关系，随便建立在哪一方都可以
    authors=models.ManyToManyField(to="Author")


    def __str__(self):
        return self.title

    class Meta:
        db_table = "app02_book"


class Publish(models.Model):
    '''
    出版社表
    出版社和书籍是一对多关系 ，关联字段写在 书籍多的一方
    '''
    nid = models.AutoField(primary_key=True)
    publish_name = models.CharField(max_length=32, verbose_name="出版社名称")
    city = models.CharField(max_length=64,verbose_name="所在城市")
    email = models.EmailField(verbose_name="邮箱")

    def __str__(self):
        return self.publish_name

    class Meta:
        db_table = "app02_publish"


class Author(models.Model):
    '''
    作者表
    '''
    nid = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32, verbose_name="作者名字")
    age = models.IntegerField()

    # 作者和 作者详情是一对一的关系，关联字段OneToOneField写在任何一方都可以
    authorDetail = models.OneToOneField(to="AuthorDetail", verbose_name="作者详情", on_delete=models.CASCADE)

    def __str__(self):
        return self.name

    class Meta:
        db_table = "app02_author"


class AuthorDetail(models.Model):
    nid = models.AutoField(primary_key=True)
    birthday = models.DateField(verbose_name="生日")
    # verbose_name  大整型数据
    telephone = models.BigIntegerField(verbose_name="手机号")
    addr = models.CharField(max_length=64, verbose_name="所在地址")

    class Meta:
        db_table = "app02_authorDetail"

```

###### （多对一查询）正向查询按字段，反向查询按表名小写

```python
# 基于对象的跨表查询
正向查询(按字段：publish)：
# 查询主键为1的书籍的出版社所在的城市
book_obj=Book.objects.filter(nid=1).first().publish.city
print(book_obj)

# 查询苹果出版社出版的所有书籍的title
反向查询(按表名：book_set)：
publish_obj=Publish.objects.filter(publish_name="苹果出版社").first()
book_list=publish_obj.book_set.all()
print(book_list)
for book_obj in book_list:
       print(book_obj.title)
```

###### 一对一查询

```
# 2、一对一查询
# author和authordetail

# 查询所有住址在北京的作者的姓名  （Author 字段建立在autho表中 ）
# 这是反向查询  （从authordetail 查 autor的name）
authordetail_obj=AuthorDetail.objects.filter(addr="北京")
# print(authordetail_obj)  # AuthorDetail object (1)

for i in authordetail_obj:
print(i.author.name)
```

###### 多对多查询

多对多正向查询：

```python
# 书籍和作者是多对多的关系 关联字段建立在book表中
# 追风筝的人02  所有作者的名字以及手机号
book_obj=Book.objects.filter(title="追风筝的人02").first()
author_list=book_obj.authors.all()
print(book_obj)
print(author_list)
for autho in author_list:
print(autho.name,autho.authorDetail.telephone)
```

多对多反向查询：

```python
# 多对多反向查询
# 查询yuan出过的所有书籍的名字  通过author查找book名字   关联字段在book中
author_obj=Author.objects.get(name="yuan")
print(author_obj,type(author_obj)) # yuan <class 'app02.models.Author'>
# 反向查询 通过autho查找书籍  反向查询按照表名小写
book_list=author_obj.book_set.all()
print("book_list",book_list)
for book in book_list:
print(book.title)
```

###### 36、基于双下划线的夸表查询（正向查询按字段，反向查询按表名小写）

```
正向查询按字段,反向查询按表名小写用来告诉ORM引擎join哪张表
```

1、基于双下划线 一对一夸表查询



```python
# 一对一夸表查询
# autho和authodetail  关联字段在author端
# 1、查询alex的手机号和地址
autho_obj1=Author.objects.filter(name="alex").values("authorDetail__telephone","authorDetail__addr")
autho_obj2=Author.objects.filter(name="alex").values_list("authorDetail__telephone","authorDetail__addr")
print(autho_obj1) # <QuerySet [{'authorDetail__telephone': 110, 'authorDetail__addr': '北京'}]>
print(autho_obj2)  # <QuerySet [(110, '北京')]>

```

2、基于双下划线的一对多跨表查询

PS:所谓的正向按字段，反向按表名小写 ，表名小写即是values后面的 values("book__title","book__price")

 -------  values("反向查找表名小写__需要查询的字段")

```python
# 2、查询苹果出版社出版过的所有书籍的名字与价格(一对多)
# publish和book  为一对多关系，关联字段在book端
# 这是反向查询
ret=Publish.objects.filter(publish_name="苹果出版社").values("book__title","book__price")
print(ret) # <QuerySet [{'book__title': 'book01', 'book__price': Decimal('100.00')}, ..

    
    
# 正向查询，通过book查找publish
ret2=Book.objects.filter(publish__publish_name="苹果出版社").values_list("title","price")
print(ret2) # <QuerySet [('book01', Decimal('100.00')), ('book02', Decimal('300.00')), ('book03',...
```

3、基于双下划线的 多对多 跨表查询

ps:   values("反向查找表名小写__需要查询的字段")

````python
# ---  双下划线 多对多查询
#  author和book
# 查询alex出过的所有书籍的名字(多对多)，关联字段在book
# 正向查询按字段查询
# 通过author 查询 book
book_list1=Book.objects.filter(authors__name="alex").values_list("title")
book_list2=Book.objects.filter(authors__name="alex")
print(book_list1)
print(book_list2)
print("----------------")

# 反向查询 按表名:book
# 通过book
book_list3=Author.objects.filter(name="alex").values_list("book__title","book__price")
print(book_list3)
````

##### 37、基于双下划线的连续跨表查询

查询橘子出版社出版过的所有书籍的名字以及作者的姓名

```python
from django.db.models import Avg, Max, Min, Count
# 基于双下划线的  连续跨表查询
# 查询橘子出版社出版过的所有书籍的名字以及作者的姓名

# 正向查询按字段
# 根据publish查找book和author的名字
# publish和book为一对多关系，book和author为多对多关系（关联字段在book端）
ret=Book.objects.filter(publish__publish_name="橘子出版社").values_list("title","authors__name")
print(ret)

# 反向查询按照表名小写
# 通过publish查找book及其相对应的作者
ret2=Publish.objects.filter(publish_name="橘子出版社").values_list("book__title","book__authors__name")
print(ret2)
# ret1，ret2 结果都一样 <QuerySet [('追风筝的人', 'alex'), ('追风筝的人02', 'alex'), ('追风筝的人', 'yuan'), ('追风筝的人02', 'yuan')]>
```

##### 38、聚合查询和分组查询

###### 1、聚合查询

```python
from django.db.models import Avg, Max, Min, Count
# 聚合查询 aggregate()
'''aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。

'''
    # 计算所有图书的平均价格
   pj_price = Book.objects.all().aggregate(avg_price=Avg("price"))
   print(pj_price, type(pj_price))  # {'avg_price': Decimal('233.333333')} <class 'dict'>

# 如果你希望生成不止一个聚合，你可以向aggregate()子句中添加另一个参数。所以，如果你也想知道所有图书价
#格的最大值和最小值，可以在后面提供给他，但是如果你自定义键，则不能放在自定义键的后面，只能放在其前面
    # 也想知道所有图书中 的最大值和最小值
    pj_price01 = Book.objects.all().aggregate(Avg("price"),Max("price"),Min("price"))
    print(pj_price01) # {'price__avg': Decimal('233.333333'), 'price__max': Decimal('400.00'), 'price__min': Decimal('100.00')}
```

###### 2、单表操作再熟悉

models.py

````python
class Emp(models.Model):
    name = models.CharField(max_length=32)
    age = models.IntegerField()
    salary = models.DecimalField(max_digits=8, decimal_places=2)
    dep = models.CharField(max_length=32)
    province = models.CharField(max_length=32)

    class Meta:
        db_table = "Emp"
````

ps:查询这个表中一共有几个部门和每个部门的名称s

```python
# 查询所有的dep名字及其个数
emp1=Emp.objects.values("dep").distinct()
emp2=Emp.objects.values("dep").distinct().count()
print(emp1)  # <QuerySet [{'dep': '销售部'}, {'dep': '人事部'}]>
print(emp2)  # 2
```

###### 3、单表分组查询

001、查询每一个部门名称以及对应的员工数，(pycharm快捷键导包 alt+enter)

```python
from django.db.models import Avg, Max, Min, Count
# 查询每一个部门名称以及对应的员工数
emp_obj=Emp.objects.values("dep").annotate(c=Count("id"))
print(emp_obj) # <QuerySet [{'dep': '销售部', 'c': 1}, {'dep': '人事部', 'c': 2}]>
```

###### orm报错：在进行 orm测试题练习的时候，创建表关系之后，进行orm查询时

报错；

```
django.db.utils.InternalError: (1054, "Unknown column 'Klass.kid' in 'field list'")
```

出现原因：

```

```

##### orm测试题

表关系：

![1591354047543](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591354047543.png)



![1591354062584](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591354062584.png)



models.py

````python
from django.db import models


# Create your models here.
# 这是一个测试题的models

class Klass(models.Model):
    '''
    班级表

    '''
    kid = models.AutoField(primary_key=True)
    caption = models.CharField(max_length=16, verbose_name="班级名称")
    # 班级表和年级表是 多对一的关系,外键字段建立在班级多的一方
    grade = models.ForeignKey("Class_Grade", on_delete=models.CASCADE)

    class Meta:
        db_table = "Klass"


gender = (
    (1, "男"),
    (0, "女"),
)


class Student(models.Model):
    '''
    学生表
    '''
    sid = models.AutoField(primary_key=True)
    sname = models.CharField(max_length=16, verbose_name="学生姓名")
    gender = models.IntegerField(choices=gender, default=1)
    # 学生和班级是多对一的关系，关联字段在student端
    Klass = models.ForeignKey("Klass", on_delete=models.CASCADE)


class Teacher(models.Model):
    '''
    老师表
    '''
    tid = models.AutoField(primary_key=True)
    tname = models.CharField(max_length=16, verbose_name="老师姓名")
    # teacher 和class是多对多的关系
    classes = models.ManyToManyField("Klass")


class Course(models.Model):
    '''
    课程表
    '''
    cid = models.AutoField(primary_key=True)
    cname = models.CharField(max_length=32, verbose_name="课程名称")

    # 课程和老师是多对一的关系  课程为多的关系，关联字段在course端
    teacher = models.ForeignKey("Teacher", on_delete=models.CASCADE)


class Score(models.Model):
    '''
    成绩表
    '''
    sid = models.AutoField(primary_key=True)
    score = models.IntegerField(verbose_name="成绩")
    # 学生和成绩是一对多的关系
    student = models.ForeignKey(to="Student", on_delete=models.CASCADE)
    # 成绩和课程是多对一的关系，关键字段就建立在score表中
    course = models.ForeignKey(to="Course", on_delete=models.CASCADE)


class Class_Grade(models.Model):
    '''
    年级表
    '''
    gid = models.AutoField(primary_key=True)
    gname = models.CharField(max_length=32, verbose_name="年级表")

````

views.py

```python
from django.shortcuts import render, HttpResponse, redirect
from django.db.models import Q, F, Aggregate, Avg, Min, Max, Count

# Create your views here.
from .models import Student, Score, Klass, Teacher, Course, Class_Grade


def orm03(request):
    # 1、 自行创建测试数据；
    # 2、 查询学生总人数；
    student_count=Student.objects.values("sid").count()
    print("学生总数〉",student_count) # 学生总数〉 3

    # 3、 查询“生物”课程和“物理”课程成绩都及格的学生id和姓名；
    # 正向查询
    ret=Score.objects.filter(course__cname__in=["生物","物理"],score__gte=60).values_list("student__sname","student__sid")
    print(ret)
    # 方向查询
    ret2=Course.objects.filter(cname__in=["生物","物理"],score__score__gte=60).values_list("score__student__sid","score__student__sname")
    print(ret2)

    # 4、 查询每个年级的班级名称及其班级数，取出班级数最多的前三个年级；
    ret3 = Class_Grade.objects.values("gid").annotate(c=Count("klass")).values("gname","c").order_by("-c")[0:3]
    print(ret3)
    # ps:查询每个年级及其班级数，取出班级数最多的前三个年级；
    ret4=Class_Grade.objects.annotate(c=Count("klass")).order_by("-c")[0:3]
    print(ret4)

    # 5、 查询平均成绩最高的学生的id和姓名以及平均成绩；
    # annotate()起到了group by 的作用，这里是按照avg进行排序
    ret5=Score.objects.values("student").annotate(avg_score=Avg("score")).order_by("-avg_score").values("avg_score","student__sid","student__sname")[0:1]
    print(ret5) # <QuerySet [{'student__sid': 2, 'student__sname': '艾弗森', 'avg_score': 99.0}]>
    # 6、 查询每个年级的学生人数；
    ret6_1=Class_Grade.objects.annotate(c=Count("klass__student__sid")).values("gname","c")
    ret6=Class_Grade.objects.values("klass__caption").annotate(c=Count("klass__student__sid")).values("gname","c")
    print(ret6) # <QuerySet [{'gname': '一年级', 'c': 2}, {'gname': '二年级', 'c': 1}, {'gname': '三年级', 'c': 0}]>
    print(ret6_1) # <QuerySet [{'gname': '一年级', 'c': 2}, {'gname': '二年级', 'c': 1}, {'gname': '三年级', 'c': 0}]>
    # 7、 查询每位学生的学号，姓名, 平均成绩
    ret7=Student.objects.annotate(Avg_score=Avg("score__score")).values("sid","sname","Avg_score")
    print(ret7) # <QuerySet [{'sid': 1, 'sname': '乔丹', 'Avg_score': 59.5}, {'sid': 2, 'sname': '艾弗森', 'Avg_score': 99.0}, {'sid': 3, 'sname': '科比', 'Avg_score': None}]
    # 8、 查询学生编号为“2”的学生的姓名、该学生成绩最高的课程名及分数；
    # 第一种
    ret8=Student.objects.filter(sid=2).annotate(Max("score__score")).values("sname","score__course__cname","score__score")[0]
    print(ret8,type(ret8))  # <QuerySet [{'sname': '艾弗森', 'score__course__cname': '体育', 'score__score': 99}]>
    # 第二种
    ret = Student.objects.filter(pk=2).order_by("-score__score").values("sname", "score__course__cname", "score__score")[0]
    print(ret,type(ret)) # {'sname': '艾弗森', 'score__course__cname': '体育', 'score__score': 99}
    # 9、 查询姓“李”的老师的个数和他们所带班级数；(需要在熟悉一下这种查找方法)
    ret9=Teacher.objects.filter(tname__startswith="李").annotate(c=Count("classes")).values("tname","c")
    print(ret9)
    # 10、查询班级个数小于5的年级id和年级名，和其个数；  # filter 和annotate 可以配合使用
    ret10=Class_Grade.objects.annotate(c=Count("klass")).filter(c__lt=5).values("gid","gname","c")
    print(ret10) # <QuerySet [{'gid': 1, 'gname': '一年级', 'c': 1}, {'gid': 2, 'gname': '二年级', 'c': 1}, {'gid': 3, 'gname': '三年级', 'c': 1}]>

    # 11、查询教过课程大于等于2门的老师的id和姓名；
    ret11=Teacher.objects.annotate(c=Count("course")).filter(c__gte=2).values("tid","tname")
    print(ret11) # <QuerySet [{'tid': 1, 'tname': '张三'}]>

    # 12、查询学过编号“1”课程和编号“2”课程的同学的学号、姓名；# 2个filter配合使用
    ret12=Student.objects.filter(score__course__cid__in=[1]).filter(score__course__cid__in=[2]).values("sid","sname")
    print(ret12) # <QuerySet [{'sid': 1, 'sname': '乔丹'}]>

    # 13、查询所带班级数最多的老师id和姓名；
    ret13=Teacher.objects.annotate(c=Count("classes")).order_by("-c"). values("tid","tname","c")[0]
    print(ret13) # {'tid': 1, 'tname': '张三', 'c': 2}

    # 14、查询有课程成绩小于60分的同学的学号、姓名；
    # 第一种方法：
    ret14=Student.objects.filter(score__score__lt=60).values("sid","sname")
    print(ret14)
    # 第二种方法：
    ret = Score.objects.filter(score__lt=60).values("student__sname", "student__pk").distinct()
    print(ret)


    # 15、----------------  查询男生、女生的人数，按倒序排列； # 单表分组查询
    # 这种方法可以查到结果，但是无法进行总数统计
    ret15=Student.objects.annotate(c=Count("sid")).values("gender","c").order_by("-c")
    print(ret15) # <QuerySet [{'gender': 0, 'c': 1}, {'gender': 0, 'c': 1}, {'gender': 1, 'c': 1}]>

    # count(1)   Count ：获取指定的对象的个数。示例代码如下：
    ret = Student.objects.values("gender").annotate(c=Count(1)).order_by("-c")
    print(ret)

    # 16、查询各个课程及相应的选修人数； # 多表分组查询
    # 同过课程找成绩，然后通过成绩的student 计算总数
    # 第一种
    ret16=Course.objects.annotate(c=Count("score__course")).values("cname","c")
    print(ret16)
    # 第二种 是标准答案
    ret = Score.objects.values("course").annotate(c=Count(1)).values("course__cname", "c")
    print(ret)

    # 17、查询同时选修了物理课和生物课的学生id和姓名；
    # 自己写的
    ret17=Student.objects.filter(score__course__cname__in=["物理"]).filter(score__course__cname__in=["生物"]).values("sid","sname")
    print(ret17)
    # in  应该是其中一个在这个 可迭代的对象中  啊？？？
    # 这个是给的答案：感觉不对啊
    ret = Student.objects.filter(score__course__cname__in=["物理", "生物"]).values("pk", "sname")
    print(ret)

    # 18、检索“3”课程分数小于60，按分数降序排列的同学学号；
    # 自己写的
    ret18=Student.objects.filter(score__course__cid=3).filter(score__score__lt=60).values("sid").order_by("-score__score")
    print(ret18) # <QuerySet []>
    # 答案：
    ret=Score.objects.filter(course_id=3, score__lt=60).order_by("-score").values("student_id")
    print(ret) # <QuerySet []>

    # 19、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列； # 多表分组查询
    # order_by() 默认是升序
    # values（）要写在annotate前面
    ret19=Score.objects.values("course__cid").annotate(avg_score=Avg("score")).order_by("avg_score","-course__cid")
    print(ret19) # <QuerySet [{'course__cname': '体育', 'avg_score': 59.0}, {'course__cname': '生物', 'avg_score': 60.0}, {'course__cname': '体育', 'avg_score': 99.0}]>


    # 20、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；
    ret20=Course.objects.annotate(mx=Max("score__score"),mi=Min("score__score")).values("cid","mx","mi")
    print(ret20)


    # return HttpResponse("这是app03的orm03试图函数")
# 
```

#### 38、接第30 章，开始写blog项目的后续

###### 博客系统之个人站点页面的数据显示和分类及其前段页面的渲染

```
技术点：
主要就是在  个人站点的数据的orm查询，及其传到前端页面的渲染
```

项目urls.py  

````python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),
    path("test/", views.test),
    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$',views.home_site),  # 新增行

]
````

views.py/def home_site

```python
# 个人站点视图函数
def home_site(request, username):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    # user = UserInfo.objects.filter(username=username).first()
    user = UserInfo.objects.filter(username="xu").first()
    user_obj = user.blog
    print(user_obj)
    # print("============", user,type(user))
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None
    print("blog.title>>>", blog.title)
    article_list = Article.objects.filter(user=user)
    print("article_list",article_list)
    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print(cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print(tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print(date_list)


    return render(request, "home_site.html",locals())
```



views.py 完整代码

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
def home_site(request, username):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    # user = UserInfo.objects.filter(username=username).first()
    user = UserInfo.objects.filter(username="xu").first()
    user_obj = user.blog
    print(user_obj)
    # print("============", user,type(user))
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None
    print("blog.title>>>", blog.title)
    article_list = Article.objects.filter(user=user)
    print("article_list",article_list)
    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print(cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print(tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print(date_list)
    return render(request, "home_site.html",locals())
```

###### 前端  home_site.html（用到了bootstrap的栅格系统）

````html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>home_site</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/bs/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .header {
            width: 100%;
            height: 60px;
            background-color: #369;
        }

        .header .title {
            font-size: 18px;
            font-weight: 100;
            line-height: 60px;
            color: white;
            margin-left: 15px;
            margin-top: -10px;

        }

        .backend {
            float: right;
            color: white;
            text-decoration: none;
            font-size: 14px;
            margin-right: 10px;
            margin-top: 10px;
        }

        .pub_info {
            margin-top: 10px;
            color: darkgray;
        }

    </style>
</head>
<body>
<div class="header">
    <div class="content">
        <p class="title">
            <span>{{ blog.title }}</span>
            <a href="" class="backend">管理</a>
        </p>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="col-md-3">
            <div class="panel panel-warning">
                <div class="panel-heading">我的标签</div>
                <div class="panel-body">
                    {% for tag in tag_list %}
                        <p>{{ tag.0 }}({{ tag.1 }})</p>
                    {% endfor %}

                </div>
            </div>
            <div class="panel panel-danger">
                <div class="panel-heading">随笔分类</div>
                <div class="panel-body">
                    {% for cate in cate_list %}
                        <p>{{ cate.0 }}({{ cate.1 }})</p>
                    {% endfor %}

                </div>
            </div>
            <div class="panel panel-success">
                <div class="panel-heading">随笔归档</div>
                <div class="panel-body">
                    {% for date in date_list %}
                        <p>{{ date.0 }}({{ date.1 }})</p>
                    {% endfor %}

                </div>
            </div>
        </div>

        <div class="col-md-9">
            <div class="article_list">
                {% for article in article_list %}
                    <div class="article-item clearfix">
                        <h5><a href="">{{ article.title }}</a></h5>
                        <div class="article-desc">
                            {{ article.desc }}
                        </div>
                    </div>
                    <div class="small pub_info pull-right">
                        <span>发布于 {{ article.create_time|date:"Y-m-d H:i" }}</span>
                        <span class="glyphicon glyphicon-comment"></span>评论({{ article.comment_count }})
                        <span class="glyphicon glyphicon-thumbs-up"></span>点赞({{ article.up_count }})
                    </div>
                    <hr>
                {% endfor %}
            </div>
        </div>
    </div>
</div>
</body>
</html>
````

截图显示：

![1591409379788](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591409379788.png)



##### 39、修改 个人站点视图函数，区分是访问的站点页面还是站点下的跳转页面

viwes.py

```python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        param = kwargs.get("param")
        print("param>>>", param)

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tag__title=param)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print(cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print(tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print(date_list)

    return render(request, "home_site.html", locals())
    return HttpResponse("test page")

```

##### 40、个人站点跳转过滤功能实现，点击“我的标签”、“随笔分类”、“随笔归档”进行跳转得实现

01、项目urls添加有名分组,针对于相同视图函数匹配不同的路径，需要传入不同的参数的解决办法；

````python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),
    path("test/", views.test),
    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$', views.home_site),  
    # 新添加
    re_path(r'^(?P<username>\w+)/(?P<condition>tag|category|archive>)/(?P<param>.*)/$', views.home_site),
]
````

02、MySQL数据库针对于create_time有约束的限制，需调整settings.py中的USE_TZ = True改为False；

03、针对于年和月的匹配规则，使用split()方法进行分割处理；

views.py

````python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        param = kwargs.get("param")
        print("param>>>", param)

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tag__title=param)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print(cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print(tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print(date_list)

    return render(request, "home_site.html", locals())


def test(request):
    # 查询xu这个用户所有的blog

    # ret = Blog.objects.filter(userinfo__username="xu").all()
    # print(ret)
    # 查询所有的user
    user_list = UserInfo.objects.all()
    print(user_list)
    for i in user_list:
        print(i.nid, i.username, i.blog_id)
    return HttpResponse("test page")

````

##### 41、博客的文章详情页面的实现

urls.py

```python
"""myblog URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, re_path
from blog import views
from django.views.static import serve
from myblog import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", views.login),
    path("index/", views.index),
    path("register/", views.register),

    # 账户注销
    path("logout/", views.logout),

    # media 配置
    re_path(r"media/(?P<path>.*)$", serve, {"document_root": settings.MEDIA_ROOT}),

    # 个人站点url
    # ?P<value1>为组名，可根据组名定位匹配值的位置， 注意：是在.group()中的标记
    #  ?P<value>的意思就是命名一个名字为value的组，匹配规则符合后面的/w+
    re_path(r'^(?P<username>\w+)$', views.home_site),
    re_path(r'^(?P<username>\w+)/(?P<condition>tag|category|archive>)/(?P<param>.*)/$', views.home_site),
    # 文章详情页面的实现
    re_path(r'^(?P<username>\w+)/articles/(?P<article_id>\d+)$',views.article_detail),


]

```

##### 42、在views.py文件中编写artickle_detail函数进行

views.py

````python
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
# Create your views here.
from django.contrib import auth
from .Myforms import UserForm
from .models import UserInfo, Blog, Category, Tag, Article, Article2Tag, ArticleUpDown, Comment
from django.db.models import Q, F, Count, Max, Min, Avg, Count
from django.db.models.functions import TruncMonth


# 登陆函数
def login(request):
    if request.method == "GET":

        return render(request, "login.html")

    else:
        response = {"user": None, "msg": None}
        user = request.POST.get("username")
        pwd = request.POST.get("password")
        user_login = auth.authenticate(username=user, password=pwd)
        print("登陆用户提交的数据〉〉", user, pwd, )
        print("authenticate验证结果〉", user_login)
        if user_login:
            response["user"] = user_login.username

        else:
            response["msg"] = "用户名或则密码错误！"
            return render(request, "login.html", {"response": response})

        # return JsonResponse(response)
        return render(request, "index.html", {"response": response})
        # return render(request,"test.html",{"response":response})


# 注册函数
def register(request):
    # 前端利用ajax 提交表单注册信息
    if request.is_ajax():
        form = UserForm(request.POST)  # 提交的用户注册数据
        response = {"user": None, "msg": None}
        if form.is_valid():
            response["user"] = form.cleaned_data.get("user")
            user = form.cleaned_data.get("user")
            pwd = form.cleaned_data.get("pwd")
            email = form.cleaned_data.get("email")
            avatar_obj = request.FILES.get("avatar")  # 拿到用户上传的图片对象
            print("提交的数据是〉〉", user, pwd, email, avatar_obj)
            if avatar_obj:
                # 将新用户注册信息写入数据库
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email, avatar=avatar_obj)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email, avatar=avatar_obj)

            else:
                # 使用默认头像
                # user_obj = UserInfo.objects.create(username=user, password=pwd, email=email)
                user_obj = UserInfo.objects.create_user(username=user, password=pwd, email=email)
        else:
            print("错误>>", form.errors)
            response["msg"] = form.errors

        return JsonResponse(response)

    form = UserForm()
    # get请求直接把UserForm对象传给页面
    return render(request, "register.html", {"form": form})


# 账户注销
def logout(request):
    auth.logout(request)

    return redirect("/login/")


# 首页函数
def index(request):
    # 将文章article从数据库提取出来  提供给前端展示
    article_list = Article.objects.all()
    print(article_list)

    return render(request, "index.html", {"article_list": article_list})


# 个人站点视图函数
# **kwargs 用于接受动态关键字参数
def home_site(request, username, **kwargs):  # username  为当前登陆人的名字

    print("当前登陆人>>", username)
    user = UserInfo.objects.filter(username=username).first()
    user_obj = user.blog
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前的登录人的所有的blog及其title
    # 查询当前站点对象
    blog = user.blog  # 这个一直是None，是一位当前对象的数据库中没有对应的数据
    article_list = Article.objects.filter(user=user)
    print("article_list", article_list)
    if kwargs:  # kwargs这是一个字典对象
        condition = kwargs.get("condition")
        print("condition>>>>>", condition)  # tag
        param = kwargs.get("param")
        print("param>>>", param)  # Tag 01

        if condition == "category":
            article_list = article_list.filter(category__title=param)

        elif condition == "tag":
            article_list = article_list.filter(tags__title=param)
            print("article_list--------", article_list)
        else:
            year, month = param.split("/")

            article_list = article_list.filter(create_time__year=year, create_time__month=month)

    # 当前用户或则当前站点 所对应的所有文章
    # 基于对象查询
    # user 和aricle 为一对多的关系
    # 反向查询 按表名小写
    # article_list = user.article_set.all()
    # 查询每一个分类名称后面对应的文章数
    # Category和Article为一对多的关系
    # 这里将title 改为nid  是不是更好？
    # ret = Category.objects.annotate(c=Count("article__title")).values("title", "c")
    # print("ret>>", ret)

    # 查询当前站点的每一个分类名称以及对应的文章数；
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    print("cate_list>>", cate_list)

    # 查询当前站点的每一个标签名称以及对应的文章数

    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    print("tag_list", tag_list)

    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y/%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("date_list>>>", date_list)

    return render(request, "home_site.html", locals())


def get_query_data(request, username, article_id):
    user = UserInfo.objects.filter(username=username).first()
    # 判断用户是否存在
    if not user:
        return render(request, "not_found.html")

    # 查询当前站点对象
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    # 通过Category查article
    cate_list = Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    article_obj = Article.objects.filter(pk=article_id).first()
    print("article_obj", article_obj)
    comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()

    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list,
            "article_obj": article_obj,
            "comment_list": comment_list
            }


def article_detail(request, username, article_id):
    # print("44444444444")
    # context = get_query_data(request, username,article_id)

    # return render(request, "article_detail.html", context)

    # 用户对象
    user = UserInfo.objects.filter(username=username).first()
    if not user:
        return render(request, 'not_found.html')

    blog = user.blog
    article_obj = Article.objects.filter(pk=article_id).first()
    # print("article_obj>>>",article_obj,article_obj.pk)
    # print("article_obj>>>",article_obj.desc)

    # 查找当前文章的所有评论，comment和article是多对一的关系
    comment_list=Comment.objects.filter(user=user,article__nid=article_id).all()

    # comment_list = Comment.objects.filter(user=user, artcile_id=article_id).all()
    print("comment_list>>>>", comment_list)
    return render(request, 'article_detail.html', locals())
````

##### 43、使用base.html进行代码的缩减

base.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>base html</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/bs/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .header {
            width: 100%;
            height: 60px;
            background-color: #369;
        }

        .header .title {
            font-size: 18px;
            font-weight: 100;
            line-height: 60px;
            color: white;
            margin-left: 15px;
            margin-top: -10px;

        }

        .backend {
            float: right;
            color: white;
            text-decoration: none;
            font-size: 14px;
            margin-right: 10px;
            margin-top: 10px;
        }

        .pub_info {
            margin-top: 10px;
            color: darkgray;
        }

    </style>
</head>
<body>
<div class="header">
    <div class="content">
        <p class="title">
            <span>{{ blog.title }}</span>
            <a href="" class="backend">管理</a>
        </p>
    </div>
</div>
<div class="container">
    <div class="row">
        <h2>000000</h2>
        <div class="col-md-3 menu">
            {% load my_tags %}
            {% get_classification_style username %}

        </div>
        <div class="col-md-9">
            {% block content %}

            {% endblock %}
        </div>
    </div>
</div>
</body>
</html>
```

###### 44、编写article_detail.html

```html
{% extends "base.html" %}
{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <div class="cont">
        {{ article_obj.desc|safe }}
    </div>

{% endblock %}
<h1>article detail</h1>
<div class="">
</div>
```



##### 44、文章详情页面的inclution_tag的使用

###### 001、编写嵌套在base.html中的get_classification_style 装饰函数

```
第一步：在所在应用下新建python文件夹  templatetags，只能为这个文件夹名字，并在这个文件夹下新建一个mytags.py  文件名字可随意
第二步：在mytags中编写相应的装饰器函数
```

###### mytags.py

````python
from django import template
from blog import models
from django.db.models import Count

register = template.Library()  # 到这里这几行代码都是固定的样式


@register.inclusion_tag(filename='classification.html')  # 这个装饰器式先加载这个html界面然后再去下面拿到数据进行渲染这个界面
def get_classification_style(username):
    print("username----------",username)
    user = models.UserInfo.objects.filter(username=username).first()
    print("user>>>>",user)
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    cate_list = models.Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = models.Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = models.Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    print("+++++++++++++",date_list)
    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list}

````

###### 002、编写 mytags.py内装饰器函数所需要的html文件classification.html

```html
<div>
    <div class="panel panel-warning">
        <div class="panel-heading">我的标签</div>
        <div class="panel-body">
            {% for tag in tag_list %}
                <p><a href="/{{ username }}/tag/{{ tag.0 }}"> {{ tag.0 }}({{ tag.1 }})</a></p>
            {% endfor %}

        </div>
    </div>
    <div class="panel panel-danger">
        <div class="panel-heading">随笔分类</div>
        <div class="panel-body">
            {% for cate in cate_list %}
                <p><a href="/{{ username }}/category/{{ cate.0 }}"> {{ cate.0 }}({{ tag.1 }})</a></p>
            {% endfor %}

        </div>
    </div>
    <div class="panel panel-success">
        <div class="panel-heading">随笔归档</div>
        <div class="panel-body">
            {% for date in date_list %}
                <p><a href="/{{ username }}/archive/{{ date.0 }}"> {{ date.0 }}({{ tag.1 }})</a></p>
            {% endfor %}

        </div>
    </div>
</div>
```

###### 003、配置base.html，在base.html中引入mytags.py文件中定义的 函数 get_classification_style 

引入方法为：

```html
{% load my_tags %}
{% get_classification_style username %}
```

base.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>home_site</title>
    <link rel="stylesheet" href="/static/blog/bs/css/bootstrap.css">
    <script src="/static/blog/js/jquery-3.3.1.min.js"></script>
    <script src="/static/blog/bs/js/bootstrap.min.js"></script>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .header {
            width: 100%;
            height: 60px;
            background-color: #369;
        }

        .header .title {
            font-size: 18px;
            font-weight: 100;
            line-height: 60px;
            color: white;
            margin-left: 15px;
            margin-top: -10px;

        }

        .backend {
            float: right;
            color: white;
            text-decoration: none;
            font-size: 14px;
            margin-right: 10px;
            margin-top: 10px;
        }

        .pub_info {
            margin-top: 10px;
            color: darkgray;
        }

    </style>
</head>
<body>
<div class="header">
    <div class="content">
        <p class="title">
            <span>{{ blog.title }}</span>
            <a href="" class="backend">管理</a>
        </p>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="col-md-3 menu">
            {% load my_tags %}
            {% get_classification_style username %}

        </div>
        <div class="col-md-9">
            {% block content %}

            {% endblock %}
        </div>
    </div>
</div>
</body>
</html>
```

##### 45、自定义标签templatetags

![1591430245057](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591430245057.png)

01、使用 @register.inclusion_tag("classification.html")

my_tags.py

```python
from django import template
from blog import models
from django.db.models import Count

register = template.Library（） # 这个方法调用需要用加（）


@register.inclusion_tag("classification.html")
def get_classification_style(username):
    user = models.UserInfo.objects.first(username=username).first()
    blog = user.blog
    # 查询当前站点的每一个分类名称及其对应的文章数
    cate_list = models.Category.objects.filter(blog=blog).values("pk").annotate(c=Count("article__title")).values_list(
        "title", "c")
    tag_list = models.Tag.objects.filter(blog=blog).values("pk").annotate(c=Count("article")).values_list("title", "c")
    date_list = models.Article.objects.filter(user=user).extra(
        select={"y_m_date": "date_format(create_time,'%%Y-%%m')"}).values("y_m_date").annotate(
        c=Count("nid")).values_list("y_m_date", "c")
    return {"blog": blog, "cate_list": cate_list, "date_list": date_list, "tag_list": tag_list}

```

@register.inclusion_tag("classification.html") 报错：

````python
TypeError: inclusion_tag() missing 1 required positional argument: 'filename'
````



此时他们的路径是：

![1591432681541](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591432681541.png)

```
TypeError: inclusion_tag() missing 1 required positional argument: 'filename'
```

![1591432448678](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591432448678.png)

写了@register.inclusion_tag(filename="classification.html") 又报错

```
TypeError: inclusion_tag() missing 1 required positional argument: 'self'
```

![1591432530252](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591432530252.png)

###### 错误原因：register = template.Library（）   #   没有加（）括号调用

总结：Python 调用类时，提示缺少self参数解决方案： 一定要加括号（）调用



02、article_detail.html,设置safe属性，防止xss攻击；

```html
{% extends "base.html" %}
{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <div class="cont">
        {{ article_obj.content|safe }}


    </div>

{% endblock %}
```

咋最后配置完成后，访问<http://127.0.0.1:8000/xu/articles/3> 得到的界面是：

![1591493737783](C:\Users\The One\AppData\Roaming\Typora\typora-user-images\1591493737783.png)





##### 46、点赞样式的构建

01、拆分css样式文件，使用link方法本地引入

article_detail.html

````html
{% extends 'base.html' %}

{% block content %}
    <h3 class="text-center">{{ article_obj.title }}</h3>
    <div class="cont">
        {{ article_obj.content|safe }}

    </div>
    <div id="div_digg">
        <div class="diggit">
            <span class="diggnum" id="digg_count">1</span>
        </div>
        <div class="buryit">
            <span class="burynum" id="bury_count">0</span>
        </div>
        <div class="clear"></div>
        <div class="diggword" id="digg_tips" style="color:red;"></div>
    </div>
{% endblock %}
````

home_site.css;

````css
* {
    margin: 0;
    padding: 0;
}

.header {
    width: 100%;
    height: 60px;
    background-color: #369;
}

.header .title {
    font-size: 18px;
    font-weight: 100;
    line-height: 60px;
    color: white;
    margin-left: 15px;
    margin-top: -10px;

}

.backend {
    float: right;
    color: white;
    text-decoration: none;
    font-size: 14px;
    margin-right: 10px;
    margin-top: 10px;
}

.pub_info {
    margin-top: 10px;
    color: darkgray;
}
````

article_detail.css

````css
.article_info .title {
    margin-bottom: 20px;
}

#div_digg {
    float: right;
    margin-bottom: 10px;
    margin-right: 30px;
    font-size: 12px;
    width: 125px;
    text-align: center;
    margin-top: 10px;
}

.diggit {
    float: left;
    width: 46px;
    height: 52px;
    background: url(/static/blog/img/upup.gif) no-repeat;
    text-align: center;
    cursor: pointer;
    margin-top: 2px;
    padding-top: 5px;
}

.buryit {
    float: right;
    margin-left: 20px;
    width: 46px;
    height: 52px;
    background: url(/static/blog/img/downdown.gif) no-repeat;
    text-align: center;
    cursor: pointer;
    margin-top: 2px;
    padding-top: 5px;
}
.clear{
    clear: both;
}
````

